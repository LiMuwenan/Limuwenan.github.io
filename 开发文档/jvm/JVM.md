# 2 内存区域

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

## 2.2 运行时数据区

**1 程序计数器**

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行**字节码的行号指示器**。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

因为一个处理器或者说一个内核同时只能处理一条指令，因此在多线程轮流切换的过程中，为了使线程切换后能够回到正确的执行位置，**每条线程都有一条独立的程序计数器**，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为**线程私有**

**2 虚拟机栈**

Java 虚拟机栈也是线程私有，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个**栈帧**用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直到执行完毕，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。

**局部变量表**存放了编译期可知的各种 Java 虚拟机基本数据类型（boolean, byte, char, short, int, float, long, double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）

这些数据类型在局部变量表中的存储空间以局部变量槽（slot）来表示，其中 64 位长度的 long 和 double 类型的数据会占用两个变量槽，其余的都只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配的局部变量空间（变量槽数量）是完全确定的。

**3 本地方法栈**

本地方法栈为虚拟机使用到的本地（Native）方法服务。

本地方法（Native Method）：使用 native 关键字修饰的方法，该方法在 Java 文件中类似一个接口，只有一个方法声明。实际的实现是使用的其他语言。所以在 Java 中调用的是其他语言的库（C/C++实现是 DLL 库）

**4 Java 堆**

**堆是被所有线程共享的区域**，这片区域就是被垃圾收集器所管理的区域，因此也被称为 ”GC堆“（Garbage Collected Heap），现在的大多数垃圾收集器都是基于**[分代收集理论](# 3.3.1 分代收集理论)**设计的

从内存分配的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的[分配缓冲区（Thread Local Allocation Buffer，TLAB）](# 2.3.1 对象的创建)，以提升对象分配时的效率。

**5 方法区**

方法区和 Java 堆一样，是一个线程共享的内存区域，它用于存储虚拟机加载的内存信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

**6 运行时常量池**

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是[常量池表（Constant Pool Table）](# 6.3.2 常量池)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

**7 直接内存**

直接内存不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。

可以通过 Native 方法直接进行内存分配，这样就绕过了虚拟机的堆内存限制。

## 2.3 HotSpot

### 2.3.1 对象的创建

Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在[常量池](# 6.3.2 常量池)中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，就先执行相应的[类加载过程](# 7.3 类加载过程)。

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需要的内存大小在类加载完成后可完全确定。[内存分配的具体过程](# 2.3.2 对象的内存布局)

**内存划分**

假设 Java 堆中内存是对决规整的，所有被使用过的内存都放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲的方向挪动一段与对象大小相等的距离，这种方式被称为**”指针碰撞“**

但是如果堆中的内存并不是规整的，被使用的内存和空闲的内存区域相互交错，这个时候不能使用简单的指针碰撞的方式，而是虚拟机需要维护一个列表，记录哪块内存是可用的，哪块是不可用的，在内存分配的时候需要从列表中找到足够的空闲内存分配，这种方式被称为**”空闲列表“**。

具体使用哪种方式根据 Java 堆的情况决定， Java 堆内存的情况又由垃圾收集器决定。

**线程安全问题**

对象创建在虚拟机中是一个十分频繁的行为，所以即使是修改一个指针所指向的位置，在并发的情况下也可能是不安全的。可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存。解决这个问题有两种可选的方案：一是对分配内存空间的动作进行同步处理——实际上虚拟机是采用 CAS 配上失败重试的方法保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在 Java 堆中预先分配一小块内存，称为**本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）**，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要进行同步锁定。

内存分配完成以后，虚拟机必须将分配的内存空间（但不包括[对象头](# 2.3.2 对象的内存布局)）都初始化为零值，如果使用了 TLAB ，这一项工作也可以提前至 TLAB 分配时顺便进行。这步操作保证了对象的实例字段在 Java 代码中不赋初值就可以直接使用。



Java 虚拟机还要对对象进行设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（直到调用 Object::hashCode()方法时才计算）、对象的 GC 分带年龄。这些信息都存储在对象头之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，[对象头](# 2.3.2 对象的内存布局)会有不同的设置方式。

### 2.3.2 对象的内存布局

对象在内存中的存储可以分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

**对象头**

对象头部分包括两类信息：第一类是用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。这部分在 32 位机和 64 位机中分别为 32 比特和 64 比特，官方称为 Mark World。对象的运行时数据不够存储在这么大的空间中，因此 Mark World 被设计为一个动态的数据结构。在 32 位机中，对象在未被同步锁定的状态下， Mark World 的 32 个比特位使用 25 个存储哈希码，4 个存储对象分代年龄，2 个用于存储锁标志位，1 个比特固定为 0，其他状态下如下表：在不同的状态下，从高位到低位分别存储了哪些信息

| 存储内容 | 标志位 | 状态 |
| :------: | :----: | :----: |
| 对象哈希码、对象分代年龄 | 01 | 未锁定 |
| 指向锁记录的指针 | 00 | 轻量级锁定 |
| 指向重量级锁的指针 | 10 | 重量级锁定 |
| 空，不需要记录信息 | 11 | GC 标记 |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01 | 可偏向 |

对象头的另一部分是类型指针，即对象指向它类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例。如果对象是一个数组，那么必须在对象头中用一块记录数组长度

**实例数据**

实例数据部分是对象真正存储的有效信息，即我们在程序代码中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。分配顺序受到虚拟机参数和字段定义顺序影响。HotSpot 虚拟机默认的分配顺序为 longs/doubles, ints, shorts, chars, bytes/booleans, oops(Ordinary Object Pointers)，相同宽度的数据被放在一起，因此会出现父类的变量出现在子类之前

**对齐填充**

在对象头不满足 8 字节的整数倍时，对齐填充将其补充为 8 字节的整数倍

### 2.3.3 对象的访问定位

**句柄访问**

使用句柄访问，Java 堆中可能会划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息

优势：句柄地址是稳定的，对象被移动后，只需要改变示例数据指针

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png)



**直接对象访问**

如果使用直接指针访问，Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问开销

优势：速度快，节省了一次指针定位的时间开销

![image-20211227165628590](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-直接指针对象访问.png)





# 3 垃圾收集器和内存分配策略

## 3.2 对象已死

### 3.2.1 引用计数法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

原理简单，判定效率高。但是在 Java 中很少使用，因为如果要实现该算法，需要配合大量的额外处理才能保证正确的工作，譬如单纯的引用计数很难解决相互循环引用的问题。



### 3.2.2 可达性分析

通过 ”GC Roots“ （[根节点枚举](# 3.4.1 根节点枚举)）的跟对象作为起始节点集，从这个节点开始根据引用关系向下搜索，搜索过程所走过的路径称为”引用链“，如果某个对象到 GC Roots 间没有任何引用链相连，则证明该对象不可能再被使用。

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png)

可以作为 GC Roots 的对象：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如当前正在运行的方法所使用到的参数、局部变量、临时变量
- 在方法区中类静态属性引用的对象，譬如引用类型静态变量
- 在方法区中常量引用的对象，譬如字符串常量池里的引用
- 在本地方法栈中 JNI （通常所说的 Native 方法）引用的对象
- Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象等，还有系统类加载器
- 所有被同步锁持有的对象
- 反映 Java 虚拟机内部情况的 JMXBean， JVMTI 中注册的回调、本地代码缓存等

除了这些固定的 GC Roots 集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时的加入，共同构成 GC Roots。

### 3.2.3 再谈引用

在 JDK 1.2 版之后，Java 堆引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用。

- 强引用时最传统的”引用“定义，是指在程序代码之中普遍存在的引用赋值，即类似”Object obj = new Object()“这种引用关系。强引用关系存在就不会被回收
- 软引用用来描述一些还有用但非必要的对象。只 被软引用的对象在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。
- 弱引用也是用来描述那些非必要对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存道下一次垃圾收集发生为止。无论内存是否足够，弱引用都会被回收。
- 虚引用也称为”幽灵引用“或者”幻影引用“，它是最弱的一种引用关系。设置一个虚引用的唯一目的是为了这个对象在被回收时收到一个通知

### 3.2.4 生存还是死亡（两次回收标记）

一个不可达对象，要宣告死亡，最多**会经历两次标记过程：**如果对象没有与 GC Roots 的引用链，那么它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。假如对象没有覆盖该方法，或者已经被虚拟机调用过，那么虚拟机将这两种情况都视为"没有必要执行"

如果对象被判定为有必要执行 finalize() 方法，会被放置在 F-Queue 队列中，稍后虚拟机自动建立一个低优先级的 Finalizer 线程执行回收（调用回收方法，不一定等到方法结束）。在 finalize() 方法中对象与引用链上的对象重新建立了关系就会被拯救回来。finalize() 只会执行一次，第一次回收时如果救回对象，第二次回收时不会再执行了。



### 3.2.5 回收方法区

通常不会在方法区实现垃圾回收。

方法区回收主要回收两个部分：废弃的常量和不再使用的类型。

**废弃常量**

例如，一个字符串常量 “java” 曾经进入常量池，但是当前系统的任何一个字符串对象的值都不是它，这个时候如果发生内存回收，且判断为有必要回收，这个常量就会被清出常量池。

**不再使用**

需要同时满足下面的三个条件：

- 该类所有的实例都已经被回收，java 堆中不存在任何该类和该类的子类实例
- 加载该类的类加载器已经被回收，这个条件除非经过精心设计的可替换的类加载器场景，如 JSP 等，否则通常很难达成
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法



## 3.3 垃圾收集算法

从对象消亡角度分为**引用计数式垃圾收集**和**追踪式垃圾收集**

### 3.3.1 分代收集理论

分代假说：

1. 弱分代假说：绝大多数对象都是朝生夕灭
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡

这两个假说推导出一个原则：收集器应该将 Java 堆划分出不同的区域，根据回收对象的年龄（熬过的收集过程次数）分配到不同的存储区域中。

因此有了 “Minor GC”，“Major GC”，“Full GC”的回收类型划分；有了“标记——复制算法”，“标记——清除算法”，“标记——整理算法”

对象之间存在跨代引用（老年代引用新生代）。这样就需要在 GC Roots 之外再在老年代中进行一次可达性分析确保没有将新生代中的对象遗漏，但是会增加系统负担。因此有了第三条法则：

3. 跨代引用假说：跨代引用相对于同代引用来说只占极少数

新生代因为跨代引用熬过垃圾收集成长为老年代，跨代引用就消除了

因此根据这条假说我们不用为了少量跨代引用进行整个老年代的扫描，只需要在新生代上建立一个全局的数据结构（[记忆集](# 3.3.4 记忆集与卡表)，Remember Set），这个结构把老年代划分为若干小块，标识出老年代的哪一块内存存在跨代引用。此后发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会加入 GC Roots。

### 3.3.2 标记 - 清除算法

标记-清除算法（Mark-Sweep）分为两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。也可以标记存活对象。标记过程就是对象是否属于垃圾的判定过程。[3.2节主要讲了对象的生存判定](# 3.2 对象已死)

缺点：

- 执行效率不稳定，如果堆中大量对象的大部分是需要被回收的，这时必须进行大量标记的清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低
- 第二个是内存空间碎片化问题，标记、清除之后会产生不连续的内存碎片，当需要分配较大对象时因为无法找到足够的连续内存而提前出发垃圾收集动作

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-MarkSweep.png)

### 3.3.3 标记 - 复制算法

标记-复制算法将内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，就将还存活的对象复制到另外一块，然后把已使用的这一块一次性清掉。

缺点：

- 如果有大量存活对象，复制的过程会产生大量开销
- 浪费了一半内存

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-MarkDuplicate.png)

大多商用虚拟机采用这种方法回收新生代。

HotSpot 虚拟机的 [Serial](# 3.5.1  Serial 收集器)、[ParNew](# 3.5.2 ParNew 收集器) 等新生代收集器采用了 Apple 式回收。把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象全部复制到另外一块 Survivor，然后直接清理 Eden 和已经使用的 Survivor。

HotSpot 虚拟机默认 Eden 和 Survivor 的空间比例为 8:1 。罕见情况下当 Survivor 不能容纳一次 Minor GC 的存活对象时，就需要依赖其他区域（大多数是老年代）进行分配担保。没有空间存放的对象将直接进入老年代

### 3.3.4 标记 - 整理算法

标记过程与标记-清除算法相同，在垃圾收集时，使存活对象向内存区域的一边移动，然后直接清理掉边界以外的内存。

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-MarkCompact.png)

标记-清除算法属于非移动式的，标记-整理算法属于移动式的。

如果移动存活对象，在老年代这种每次回收都有大量对象存活的内存区域，移动对象是一个极为笨重的操作，而且这种移动需要全程暂停用户应用程序才能够进行，被称为 “Stop The World”

如果像标记-清除算法一样不移动和整理的话，就需要 “分区空闲链表” 来解决内存分配问题。

即使不移动使得回收器的效率更高，但是因为内存分配和访问的频率更高，这部分的吞吐量是下降的，使得总吞吐量也下降。



## 3.4 HotSpot的算法细节实现

### 3.4.1 根节点枚举

**所有垃圾收集器在根节点枚举这个阶段都必须暂停用户线程**。现在可达性分析耗时最长的查找引用链过程已经可以和用户线程并发，但是根节点枚举始终还是必须在一个能保障一致性（这里的意思是，整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断地变化，不能保证这点则不能保证分析结果的准确性）的快照中进行，这是 “Stop The World” 的一个重要原因。

HotSpot 使用一组称为OopMap 的数据结构来记录所有对象的引用。一旦类加载动作完成，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，在[即时编译](# 11.2 即时编译器)过程中，也会在特定的位置记录下栈里和寄存器那些位置是引用。

### 3.4.2 安全点

OopMap 可以快速准确的完成 GC Roots 枚举，但是可能导致引用关系变化，或者说可以导致 OopMap 内容变化的指令非常多，如果为每条指令生成对应的 OopMap 会需要大量的额外存储空间。因此引出了安全点（Safe Point）的概念。

安全点的选取基本上是以 “是否具有让程序长时间执行的特征（指令系列复用，如方法调用、循环跳转、异常跳转等）” 为标准进行选定的。

垃圾收集前使所有线程都跑到安全点：

**抢先式中断**：系统首先暂停所有线程，发现哪些线程没在安全点上就恢复这些线程，直到它到达安全点。现在几乎没有虚拟机如此实现

**主动式中断**：不直接对线程操作。设置一个标志位，各线程主动轮询这个标志位，发现需要中断就自己到附近的安全点挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在 Java 堆上分配内存的地方，为了检查是否要启动垃圾收集，避免没有内存分配新对象。

HotSpot 使用**内存保护陷阱**实现轮询操作，只需要一条汇编。用户需要挂起线程，虚拟机把内存页设置为不可读，线程执行到读取内存页处就会出现异常，然后在预先注册的异常处理器中挂起线程

### 3.4.3 安全区域

如果用户线程处于 Sleep 状态或者 Blocked 状态，这个时候线程无法自己跑到安全点上，因此需要安全区域。

当用户线程执行到安全区域里面的代码，首先会标识自己进入了安全区域，当发生垃圾收集时就不需要管该线程。当该线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要用户线程停止的阶段），直到这些阶段过去才能继续执行。

### 3.4.4 记忆集与卡表

[分代收集理论](# 3.3.1 分代收集理论)中解决跨代引用问题。在新生代中加入记忆集，避免把整个老年代加入 GC Roots 扫描范围。

记忆集是一种用于记录从非收集区指向收集区域的指针集合的抽象数据结构。收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针，不需要了解这些跨代指针的具体实现。设计者在实现记忆集的时候，便可以选择更为粗犷记录粒度来节省记忆集的存储和维护成本。记录精度：

- 字长精度：每个记录精确到一个机器字长（处理器寻址位数），该字长包含跨代指针。
- 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
- 卡精度：每个记录精确到一块内存区域，该区域内含有跨代指针。

HotSpot 通过数组形式实现卡表，字节数组的每一个元素对应一个卡页，为 512 字节。

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-CardTable.png)

一个卡页的内存中通常包含不止一个对象，只要卡页内有一个对象存在跨代指针，那就将对应卡表的数组元素的值标为 1，称为这个元素变脏了，变脏的时间点原则上发生在引用类型字段赋值的那一刻。

卡表的两个问题：

- 如何何时更新卡表
- 伪共享

### 3.4.5 写屏障

通过写屏障计数维护卡表的状态（数据变脏之后何时更新维护卡表）。写屏障可以看作在虚拟机层面对引用类型赋值这个动作的 AOP 切面，在赋值时产生一个环形通知，在赋值前后都在写屏障的覆盖范畴内。

应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令（更新卡表指令）。一旦在写屏障中增加了更新了卡表操作（引用类型赋值），无论是否是老年代对新生代的引用，都会产生相应指令（更新卡表指令）增加开销。这和 Minor GC 扫描整个老年代相比代价低了很多。

卡表在高并发下面临着 “伪共享” 问题。现在处理器缓存系统以缓存行为单位存储，当多线程修改互相独立额变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回，无效化或者同步）而导致性能降低。实际没有同时访问同一块内存区域，但是访问了同一个缓存行，像是在共同访问。

假设处理器缓存行大小 64 字节，一个卡表元素占 1 个字节，64 个元素刚好占用一个缓存行。这个 64 个卡表元素对应的卡页总的内存为 32KB，也就是说如果不同的线程更新正好处于这 32KB 的内存区域，就会导致更新卡表时正好写入同一个缓存行而影响性能。为了避免伪共享问题，先检查卡表标记，如果标记过了就不再标记。

标记判断过程和伪共享问题各有损耗，需要根据实际情况进行设置（JDK 7 后可以设置是否打开判断）。

### 3.4.6 并发可达性分析

把遍历图结构过程中遇到的对象，按照 ”是否访问过“ 这个条件标记成以下三种颜色：

- 白色：表示对象尚未被垃圾收集器访问过。可达性分析刚开始都是白色的，可达性分析结束后有白色的代表不可达。
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象所有引用都已经扫描过。黑色的对象代表已经扫描过。它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- 灰色：表示已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

如果收集器和用户线程并发，收集器在对象图上做标记，同时用户线程在修改引用关系，会产生两种问题：

- 原本消亡的对象标记为存活。这会增加这次收集的浮动垃圾，下次回收就好
- 原本存活的对象标记为消亡。这会发生错误。

产生第二条误标记的原因是：

- 赋值器插入了一条或多条从黑色对象向白色对象的新引用
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

解决对象消失问题需要打破上面的情形的任意一种。两种解决方案**增量更新**和**原始快照**

增量更新（Increment Update）破坏第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根重新扫描一次（有些断开了没有扫描到就会变成浮动垃圾）

原始快照（Snapshot At The Begining，SATB）破坏第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，再将这些记录过的引用关系的灰色对象为根扫描一次。理解为，无论关系是否删除，都按照扫描开始的那一刻的对象图快照进行搜索。

以上操作都是通过写屏障实现。

[CMS](# 3.5.6 CMS 收集器) 使用增量更新， [G1](# 3.5.7 Garbage First 收集器) 和 [Shenandoah](# 3.6.1 Shenandoah 收集器) 使用原始快照。

## 3.5 经典垃圾收集器

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-GarbageCollection.png)

上图展示了 7 款垃圾收集器，两者之间有连线代表可以配合使用，它们各自所处的区域就是它们的收集区域。



| 垃圾收集器 | 收集代 | 使用算法 | 配合收集器 | 备注 |
| :----------: | :----: | :----: | :----: | :----: |
| Serial | 新生代 | 标记-复制 | CMS，Serial Old | JDK 9 开始不能与 CMS 配合 |
| ParNew | 新生代 | 标记-复制 | CMS，Serial Old | JDK 9 开始不推荐与 CMS 配合，取消 Serial Old 配合 |
| Parallel Scavenge | 新生代 | 标记-复制 | Parallel Old，Serial Old |自适应垃圾收集调节策略|
| Serial Old | 老年代 | 标记-整理 | Serial，Parallel Scavenge |JDK 5 及以前和 Parallel Scavenge 配合|
| Parallel Old | 老年代 | 标记-整理 | Parallel Scavenge |JDK 6 开始提供|
| CMS | 老年代 | 标记-清除 | Serial，ParNew | JDK 9 开始不能与 Serial 配合，不推荐与 ParNew 配合 |
| G1 | 全堆（Region） | 标记-复制 | 无 | Region 内存模型。整体看为标记-整理算法 |
| Shenandoah | 全堆（Region） | 标记-复制 | 无 |低延迟，并发标记、并发回收、并发引用更新|
| ZGC | 全堆 | 标记-整理 | 无 | 低延迟，读屏障、染色指针 |
| Epsilon |      |      |      |      |





### 3.5.1  Serial 收集器

新生代收集器。单线程工作，只使用一个核心或者一个线程进行垃圾收集工作，没有线程交互开销，有最高的单线程收集效率；新生代采用[标记-复制](# 3.3.3 标记 - 复制算法)算法，对于内存资源受限的环境，它是所有收集器中额外使用内存最少的。

### 3.5.2 ParNew 收集器

实质上是 Serial 收集器的多线程版本。采用[标记-复制](# 3.3.3 标记 - 复制算法)算法

默认线程数量与处理器核心数相同

### 3.5.3 Parallel Scavenge 收集器

新生代收集器，[标记-复制](# 3.3.3 标记 - 复制算法)算法。**注重达到一个可控制的吞吐量**


$$
吞吐量=\frac{运行用户代码时间}{运行用户代码时间+垃圾收集时间}
$$

- -XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间
- -XX:GCTimeRatio：吞吐量大小

收集器会尽力保证使得垃圾收集时间控制在设置的停顿时间内，通过牺牲吞吐量和新生代空间达到这个要求。如果设置的太小，因为新生代空间太小反而会增加垃圾收集次数进而降低总吞吐量。

- -XX:UseAdaptiveSizePolicy：自适应参数开关

打开这个开关就不需要人为的调节新生代大小、Eden 和 Survivor 比例、晋升老年代对象大小等参数，虚拟机会根据当前系统运行状况动态调整合适的参数，这称为**垃圾收集的自适应调节策略**。

### 3.5.4 Serial Old 收集器

Serial 老年代版本

老年代收集，采用[标记-整理](# 3.3.4 标记 - 整理算法)算法。单线程收集

### 3.5.5 Parallel Old 收集器

Parallel Scavenge 老年代版本

进行老年代收集，采用[标记-整理](# 3.3.4 标记 - 整理算法)算法，多线程收集。JDK 6开始提供

### 3.5.6 CMS 收集器

CMS（Concurrent Mark Sweep）是以**获取最短停顿时间为目标**

很大一部分应用在 Java 应用集中在互联网网站或者基于浏览器的 B/S 架构的服务端上

基于[标记-清除](# 3.3.2 标记 - 清除算法)算法实现，整个过程分为四个步骤：

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）

初始标记和重新标记步骤需要 “Stop The World”

**初始标记**

仅标记 GC Roots 能够直接关联的对象，速度很快

**并发标记**

从 GC Roots 的直接关联对象开始遍历整个对象图，耗时长但是不需要暂停，可以与用户线程并发运行

**重新标记**

修正并发标记期间，因为用户线程继续工作而导致标记产生变动的那一部分对象的标记记录（[见3.4.6关于增量更新的讲解](# 3.4.6 并发可达性分析)），通常比初始标记阶段长，远比并发标记阶段时间短。需要STW

**并发清除**

清理删除掉标记阶段被判断死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程并发执行的。



并发阶段默认启动$（处理器核心数量 + 3）/ 4$ 的线程数，用户核心越多，占用比例越小

缺点：

- 并发阶段占用了一部分线程，导致用户程序处理变慢，降低总吞吐量
- 处理器核心不足四个时， CMS 对用户程序的影响很大。为了缓解该情况，虚拟机提供了一种增量式并发收集器（Incremental Concurrent Mark Sweep/i-CMS），在并发标记、清理（这两个阶段在 CMS 中和用户线程并发的）的时候让收集器线程、用户线程交替运行，尽量减少垃圾收集线程独占资源的时间（但是这种方法效果一般，在 JDK 7 标记弃用）。CMS 无法处理**浮动垃圾**（用户线程在标记过程以后产生的新的垃圾对象），有可能出现 “Concurrent Mode Failure” 失败进而导致一次完全 “Stop The World” 的 Full GC。同样在垃圾收集阶段因为用户线程还在运行，所以需要预留足够空间给用户线程使用，因此 CMS 不会等待老年代几乎全满才进行收集。 JDK 5 默认设置当老年代使用 68% 空间后就被激活。JDK 6 默认提升到 92%。如果预留的空间还是不够就会触发一次 “**并发失败 （Concurrent Mode Failure）**”，这时候就会触发 Serial Old 进行一次老年代收集
- [标记-清除](# 3.3.2 标记 - 清除算法)算法导致内存空间有很多内存碎片，没有足够的连续空间进行分配，从而触发一次 Full GC。-XX:+UseCMSCompactAtFullCollection 开关在 Full GC 时开启内存碎片整理，这导致停顿时间变长。-XX:CMSFullGCsBeforeCompaction 设置次数，经过多少次不整理空间的 Full GC 后，下一次先进行碎片整理。这两个参数在 JDK 9 开始废弃

### 3.5.7 Garbage First 收集器

里程碑，开创了面向局部收集的设计思路和基于 Region 的内存布局形式。主要面向服务端应用的垃圾收集器

不纯粹的追求低延迟，在延迟可控的情况下能够获得尽可能高的吞吐量。

**停顿预测模型：**能够支持指定在一个长度为 M 的时间片段内，消耗在垃圾收集上的时间大概率不超过 N 毫秒这样的目标。

G1 不再是面向整个新生代或者老年代或者 Java 堆的思想进行垃圾收集，衡量标准不再是分代，而是哪块内存中存放的垃圾数量最多，回收收益最大。

Region 内存模型是 G1 能够实现这个目标的关键。G1 不再坚持固定大小以及固定大小的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间或者老年代空间，收集器对不同角色的 Region 采用不同的策略进行回收。

Humongous 区域：Region 中用来存储大对象的区域，超过 Region 一半的大小就是大对象。超过整个 Region 大小的对象使用 N 个连续的 Humongous 存储。

**因此 G1 依靠 Region 区域划分，有效的避免全区域收集，从而实现可预测时间的停顿模型**



需要解决的问题：

**多个 Region 划分之后的跨 Region 引用问题**

每个 Region 都维护一个[记忆集和卡表](# 3.4.4 记忆集与卡表)，记录下其他 Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。

Key 是别的 Region 的起始地址， Value 是一个集合，里面存储的元素是卡表索引号。因为卡表变多变复杂，因此 G1 使用了 10% ~ 20% 堆容量。

**并发阶段如何保证收集线程和用户线程互不干扰的并发执行**

G1 垃圾收集器采用的是[原始快照](# 3.4.6 并发可达性分析)的方式保证垃圾收集线程与用户线程并发时标记过程的正确性。

用户线程持续运行过程中会不断创建新的对象，G1 为每一个 Region 设计了两个 TAMS（Top at Mark Start）的指针，把 Region 中的一部分空间划分出来用于并发回收过程新对象的分配，新分配对象的地址必须在这两个指针以上。

**怎样建立可靠的停顿预测模型**

G1 收集器的停顿预测模型以**衰减均值**为理论基础实现的，在垃圾收集过程中，G1 会记录每个 Region 的回收耗时、每个 Region 记忆集里的脏卡数量等各个可测量的步骤花费成本，并分析得出平均值、标准偏差、置信度等统计数据。衰减平均值是指它会比普通的平均值更容易受到新数据的影响。通过这些信息，G1 可以确定应该优先回收哪些 Region 而获得较高收益。



G1 收集器的四个步骤：

- **初始标记：**仅仅标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确的在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。
- **并发标记：**从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这个阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理 [SATB记录](# 3.4.6 并发可达性分析) 下的在并发时有引用变动的对象
- **最终标记：**对用户线程做另一个短暂的暂停，用于处理并发阶段结束后遗留下来的  [SATB记录](# 3.4.6 并发可达性分析)
- **筛选回收：**负责更新 Region 的统计数据，对各个 Regin 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

只有并发标记阶段不需要 ”Stop The World“。

G1 可以设定停顿时间，如果设置了太短的停顿时间，每次只能回收一点内存，导致收集速度不能跟上分配速度，垃圾慢慢堆积最终导致 Full GC 发生。



从 G1 开始，设计导向不约而同的变为应付应用的内存分配速率，而不追求一次把整个 Java 堆全部整理干净。只要回收速度能够跟上分配速度就可以了。



**G1 和 CMS 的相同点与不同点：**

G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都比 CMS 高。

G1 和 CMS 都是用卡表来处理跨代指针，G1 的卡表比 CMS 的实现更复杂。

CMS 使用使用写后屏障维护卡表，G1 使用写后屏障进行同样的卡表维护操作外，使用了 SATB 算法，还需要使用写前屏障跟踪指针变化。相比增量更新算法，原始快照算法能够减少并发标记和重新标记阶段的消耗

CMS 的写屏障实现是直接的同步操作，G1 使用类似消息队列的结构，把写屏障要做的事情放到队列里，然后再异步处理。



## 3.6 低延迟垃圾收集器

垃圾收集器的三个衡量标准：内存占用、吞吐量、延迟。

### 3.6.1 Shenandoah 收集器

Shenandoah 也是基于 Region 的内存布局，大对象管理和默认回收策略都与 G1 相同，与 G1 的三个不同：

- 支持并发整理算法，G1 的回收阶段是可以多线程并行的，但不能与用户线程并发
- 默认不使用分代收集
- 使用 ”连接矩阵“ 的全局数据结构维护跨 Region 引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题发生的概率。

工作的九个阶段：

- **初始标记：**标记与 GC Roots 直接关联的对象
- **并发标记：**遍历图对象，标记出全部可达对象
- **最终标记：**处理剩余的 [SATB记录](# 3.4.6 并发可达性分析)  扫描，在这个阶段计算回收价值最高的 Region，将这些 Region 组成回收集。
- **并发回收：**先把存活对象复制到未使用的 Region。这个过程和用户线程并发，为了解决并发问题，使用了读屏障和 ”Brooks Pointers“ 的转发指针来解决
- **初始引用更新：**并发回收阶段复制对象结束后，需要把堆中所有指向旧对象的引用修正到复制后的新地址，这被称作引用更新。确保对象移动完成。
- **并发引用更新：**按照内存物理地址顺序，线性的搜索出引用类型，把旧值改为新值。转发指针处理并发冲突。
- **最终引用更新：**修正 GC Roots 中的引用
- **并发清理：**整个回收集的 Region 已经没有存活对象，直接并发清理

Shenandoah 必须要等到引用更新阶段结束之后才能够释放回收集中的 Region，这意味着堆中几乎所有对象都存活的情况下，需要 1 : 1 复制对象到新 Region 的话，就必须有一半的空闲 Region 来完成收集

**转发指针（Brooks Pointers）：**对象布局结构最前面存在一个转发指针，这个指针最开始是指向对象自身，当进行了并发回收过程的复制阶段，转发指针会将转发地址指向新的内存地址，这样即使通过旧对象引用访问，也能转发到新内存地址上，访问到正确的内容。

如果在并发写入的话会出现冲突，所以转发指针的访问操作需要进行同步处理，让收集器线程和用户线程只能有一个对转发指针能够访问。同步操作使用了 CAS 机制。

因为 Shenandoah 使用了读屏障机制，但是对象访问要比对象写入的操作多得多，因此这个读屏障会降低收集器的工作效率。Shenandoah 计划在 JDK 13 将读屏障改进为基于引用访问的屏障，即只对引用对象进行拦截，对原生数据类型和非引用类型不进行拦截，以此提升效率。

### 3.6.2 ZGC 收集器

ZGC 收集器是一款基于 Region 内存布局的，暂时不设分代的，使用读屏障、染色指针和内存多重映射等技术来实现可并发的[标记-整理算法](# 3.3.4 标记 - 整理算法)的，以低延迟为首要目标的垃圾收集器。

ZGC 的 Region 具有动态性，动态的创建和销毁，以及动态的区域容量大小。

在 x64 硬件平台下：

- 小型：容量固定为 2MB，用于放置 256KB 的小对象
- 中型：容量固定为 32MB，用于放置大于等于 256KB 但小于 4MB 的对象
- 大型：容量不固定，但必须为 2MB 的整数倍，用于放置 4MB 以上的大对象。每个大 Region 只会存放一个大对象。大 Region 不会被重分配（ZGC 的一个处理动作）

ZGC 使用读屏障和染色指针技术（Colored Pointer）。

**染色指针：**标记阶段将标记打在引用对象的指针上，在不读取对象（Serial 收集器打在对象头上）的情况下就可以知道该对象是否被移动过

64位地址，前 18 位在 Linux 不能用来寻址，还剩余 46位， ZGC 使用了剩余 64 位的高 4 位进行染色指针标记。虚拟机可以直接通过染色指针看到引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过 finalize() 方法才能被访问

染色指针的三大优势：

- 一旦某个 Region 的存活对象被一走之后，这个区域立即就能够被释放和重用，而不必等待整个堆中所有指向该 Region 的引用都被修正后才能清理。这是 ”自愈“ 特性，比 Shenandoah 的一个大优势，理论上只要有一个空闲的 Region 就能够完成收集，而 Shenandoah 必须要等到引用更新阶段结束之后才能够释放回收集中的 Region，这意味着堆中几乎所有对象都存活的情况下，需要 1 : 1 复制对象到新 Region 的话，就必须有一半的空闲 Region 来完成收集

- 染色指针可以大幅减少内存屏障的使用数量，对吞吐量的影响较小。ZGC 只使用了读屏障，没有使用写屏障，并且暂时没有分代收集，不存在跨代引用问题
- 染色指针可以作为一种可扩展的存储结构用来记录更多的对象标记、重定位过程相关的数据，以便日后提高性能。

染色指针面临的一个问题是：操作系统是否支持随意的更改内存中的任意几位，操作系统只会把一个指针当作一个内存地址对待，而不会管哪几位是标志位。因此提出了使用到了**虚拟内存映射技术**

虚拟内存映射技术：处理器使用分页管理机制把线性的地址空间和物理地址空间分别划分为大小相同的块，这样的内存称为 ”页“。通过在线性虚拟空间的页与物理地址空间的页之间建立映射表，分页管理机制会进行线性地址到物理地址的空间映射，完成线性地址到物理实地址的转化

ZGC 使用多重映射技术将多个虚拟地址映射到同一个物理地址上，这种多对一的关系使得虚拟机的内存容量看起来比物理内存大很多。染色指针标志位将地址分段，只要将这些不同的地址映射到同一块物理内存，经过多重映射转化，就可以正常寻址了。



ZGC 收集器的四个阶段：

- **并发标记：**该阶段之前和之后也有初始标记和最终标记阶段，与 G1 一样。该阶段也是遍历图做可达性分析。标记阶段更新指针中的 Marked 0 和 Marked 1.
- **并发预备重分配：**根据特定条件统计需要回收哪些 Region，将这些 Region 组成重分配集。 ZGC 每次回收都会扫描所有的 Region，用范围更大的扫描成本换取省去 G1 中记忆集的维护成本。

- **并发重分配：**把重分配集中的存活对象复制到新的 Region，并为重分配集中的每个 Region 维护一个转发表，记录从旧对象到新对象的转向关系。因为染色指针可以从引用上就知道哪些对象位于重分配集中，如果用户线程并发访问了一个位于重分配集中的对象，这次访问将会被内存屏障截获，然后立即根据 Region 上的转发表将访问转发到新复制的对象上，并同时修正更新该引用的值。这个过程称为 ”自愈“。一旦重分配集的某个 Region 被复制完成后，这个区域就能立即被释放，但是转发表还需要保留。
- **并发重映射：**修正整个堆中指向重分配集中旧对象的所有引用。因为 ”自愈“ 的关系，这个阶段没有那么迫切，所以 ZGC 将这个阶段的工作合并到了下一次垃圾收集循环中的并发标记阶段，因为这个阶段也是要进行一次全图遍历。

## 3.7 选择合适的垃圾收集器

### 3.7.1 Epsilon 收集器

### 3.7.2 收集器的权衡

### 3.7.3 虚拟机及垃圾收集器日志

### 3.7.4 垃圾收集器参数总结

# 6 类文件结构

### 6.3 Class 类文件的结构

Class 类文件的两种数据类型：

- 无符号数：u1, u2, u4, u8 来分别代表 1 字节，2 字节， 4 字节和 8 字节的无符号数，无符号数用来描述数字、索引引用、数量值胡总和按照 UTF-8 编码构成的字符串
- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，表的命名习惯以 "_info" 结尾。表用于描述有层次关系的复合结构的数据



|        名称         |      类型      |         数量          |              描述               |
| :-----------------: | :------------: | :-------------------: | :-----------------------------: |
|        magic        |       u4       |           1           | 是否能被虚拟机接收的 Class 文件 |
|    minor_version    |       u2       |           1           |            次版本号             |
|    major_version    |       u2       |           1           |            主版本号             |
| constant_pool_count |       u2       |           1           |     常量池入口，常量池长度      |
|    constant_pool    |    cp_info     | constant_pool_count-1 |                                 |
|    access_flags     |       u2       |           1           |            访问标志             |
|     this_class      |       u2       |           1           |             类索引              |
|     super_class     |       u2       |           1           |            父类索引             |
|  interfaces_count   |       u2       |           1           |          接口索引集合           |
|     interfaces      |       u2       |   interfaces_count    |                                 |
|    fields_count     |       u2       |           1           |           字段表集合            |
|       fields        |   field_info   |     fields_count      |                                 |
|    methods_count    |       u2       |           1           |                                 |
|       methods       |  method_info   |     methods_count     |                                 |
|  attributes_count   |       u2       |           1           |                                 |
|     attributes      | attribute_info |   attributes_count    |                                 |

### 6.3.1 魔数与 Class 文件的版本

每个 Class 文件的前 4 个字节被称为 ”魔数“，用来描述是否为能够被虚拟机接收的 Class 文件。Java Class 文件的魔数为 0xCAFEBABE



紧接着魔数的是 4 个字节的版本号，2 个字节的次版本号和 2 个字节的主版本号

### 6.3.2 常量池

常量池入口，一个 u2 类型，代表常量池容量计数值，容量从 1 开始记。假设这个值为 0x0016，十进制的 22，这就代表常量池中有 21 项常量，索引范围 1~21，只有常量池的索引从 1 开始。

常量池中主要存放两大常量：字面量（Literal）和符号引用（Symbolic Reference）

字面量如文本字符串、被声明为 final 的常量值等

符号引用主要包括：

- 被模块导出或开放的包（Package）
- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符
- 方法句柄和方法类型
- 动态调用点和动态常量

在 Class 文件中不会保存各个方法、字段最终在内存中的布局信息。当虚拟机做[类加载](# 7 虚拟机类加载机制)时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址。

截至到 JDK 13，常量池总共有 17 种不同类型的常量

**常量池项目类型**

|               类型               | 标志 |              描述              |
| :------------------------------: | :--: | :----------------------------: |
|        CONSTANT_Utf8_info        |  1   |       UTF-8 编码的字符串       |
|      CONSTANT_Integer_info       |  3   |           整型字面量           |
|       CONSTANT_Float_info        |  4   |          浮点型字面量          |
|        CONSTANT_Long_info        |  5   |          长整型字面量          |
|       CONSTANT_Double_info       |  6   |       双精度浮点型字面量       |
|       CONSTANT_Class_info        |  7   |       类或接口的符号引用       |
|       CONSTANT_String_info       |  8   |        字符串类型字面量        |
|      CONSTANT_Fieldref_info      |  9   |         字段的符号引用         |
|     CONSTANT_Methodref_info      |  10  |       类中方法的符号引用       |
| CONSTANT_InterfaceMethodref_info |  11  |      接口中方法的符号引用      |
|    CONSTANT_NameAndType_info     |  12  |    字段或方法的部分符号引用    |
|    CONSTANT_MethodHandle_info    |  15  |          表示方法句柄          |
|     CONSTANT_MethodType_info     |  16  |          表示方法类型          |
|      CONSTANT_Dynamic_info       |  17  |      表示一个动态计算常量      |
|   CONSTANT_InvokeDynamic_info    |  18  |     表示一个动态方法调用点     |
|       CONSTANT_Module_info       |  19  |          表示一个模块          |
|      CONSTANT_Package_info       |  20  | 表示一个模块中开放或者到处的包 |

**CONSTANT_Class_info 型常量的结构**

| 类型 |    名称    | 数量 |
| :--: | :--------: | :--: |
|  u1  |    tag     |  1   |
|  u2  | name_index |  1   |

tag 是标志位，用于区分常量类型； name_index 是常量池索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型的常量，此常量代表了这个类的（或者接口）的全限定名

**CONSTANT_Utf8_info 型常量的结构**

| 类型 |  名称  |  数量  |
| :--: | :----: | :----: |
|  u1  |  tag   |   1    |
|  u2  | length |   1    |
|  u1  | bytes  | length |

tag 是标志位，用于区分常量类型；length 是说明这个 UTF-8 编码的字符串占用了多少个字节，后面紧跟了 length 字节的 UTF-8 编码值

UTF-8 缩略编码和 UTF-8 编码的区别是：从 '\u0001' 到 '\u007f' 之间的字符（1~127 的 ASCII 码）的缩略编码使用一个字节表示，从 '\u0080' 到 '\u07ff' 之间的所有字符的缩略编码用两个字节表示，从 '\u0800' 到 '\uffff' 之间的所有字符缩略编码按照普通的 UTF-8 编码规则使用三个字节

一个 CONSTANT_Utf8_info 类型的最大长度是两个字节，也就是 64KB，所以理论上类名、方法名等最大长度不能超过 64KB

**CONSTANT_Integer_info 型常量结构**

| 类型 | 名称  | 数量 |
| :--: | :---: | :--: |
|  u1  |  tag  |  1   |
|  u4  | bytes |  1   |

tag 是标志位，bytes 是值

**CONSTANT_Float_info 型常量结构**

| 类型 | 名称  | 数量 |
| :--: | :---: | :--: |
|  u1  |  tag  |  1   |
|  u4  | bytes |  1   |

**CONSTANT_Long_info 型常量结构**

| 类型 | 名称  | 数量 |
| :--: | :---: | :--: |
|  u1  |  tag  |  1   |
|  u8  | bytes |  1   |

**CONSTANT_Double_info 型常量结构**

| 类型 | 名称  | 数量 |
| :--: | :---: | :--: |
|  u1  |  tag  |  1   |
|  u8  | bytes |  1   |

**CONSTANT_String_info 型常量结构**

| 类型 | 名称  | 数量 |
| :--: | :---: | :--: |
|  u1  |  tag  |  1   |
|  u2  | index |  1   |

index 指向字符串字面量的索引

**CONSTANT_Fieldref_info 型常量结构**

| 类型 |    名称     | 数量 |
| :--: | :---------: | :--: |
|  u1  |     tag     |  1   |
|  u2  | class_index |  1   |
|  u2  | name_index  |  1   |

第一个 index 指向声明字段的类或接口描述符 CONSTANT_Class_info 的索引项；

第二个 index 指向字段描述符 CONSTANT_NameAndType_info 的索引项

**CONSTANT_Methodref_info 型常量结构**

| 类型 |    名称     | 数量 |
| :--: | :---------: | :--: |
|  u1  |     tag     |  1   |
|  u2  | class_index |  1   |
|  u2  | name_index  |  1   |

第一个 index 指向声明方法的类描述符 CONSTANT_Class_info 的索引项；

第二个 index 指向名称及类型描述符 CONSTANT_NameAndType_info 的索引项

**CONSTANT_InterfaceMethodref_info 型常量结构**

| 类型 |    名称     | 数量 |
| :--: | :---------: | :--: |
|  u1  |     tag     |  1   |
|  u2  | class_index |  1   |
|  u2  | name_index  |  1   |

第一个 index 指向声明方法的接口描述符 CONSTANT_Class_info 的索引项；

第二个 index 指向名称及类型描述符 CONSTANT_NameAndType_info 的索引项

**CONSTANT_NameAndType_info 型常量结构**

| 类型 |    名称     | 数量 |
| :--: | :---------: | :--: |
|  u1  |     tag     |  1   |
|  u2  | class_index |  1   |
|  u2  | name_index  |  1   |

第一个 index 指向字段或方法名称常量项的索引；

第二个 index 指向字段或方法描述符常量项的索引

**CONSTANT_MethodHandle_info 型常量结构**

| 类型 |      名称       | 数量 |
| :--: | :-------------: | :--: |
|  u1  |       tag       |  1   |
|  u2  | reference_kind  |  1   |
|  u2  | reference_index |  1   |

reference_kind 值必须在 1~9 ，决定了方法句柄的类型。方法句柄类型的值表示方法句柄的字节码行为

reference_index 对常量池的有效索引

**CONSTANT_MethodType_info 型常量结构**

| 类型 |       名称       | 数量 |
| :--: | :--------------: | :--: |
|  u1  |       tag        |  1   |
|  u2  | descriptor_index |  1   |

descriptor_index 对常量池的有效索引，常量池在该索引处的项必须是 CONSTANT_Utf8_info， 表示方法的描述符

**CONSTANT_Dynamic_info 型常量结构**

| 类型 |            名称             | 数量 |
| :--: | :-------------------------: | :--: |
|  u1  |             tag             |  1   |
|  u2  | bootstrap_method_attr_index |  1   |
|  u2  |     name_and_type_index     |  1   |

bootstrap_method_attr_index 必须是当前 Class 文件中引导方法表的 bootstrap_methods[] 数组的有效索引

name_and_type_index 当前常量池的有效索引，常量池在该索引处的结构必须是 CONSTANT_NameAndType_info，表示方法名和方法描述符

**CONSTANT_InvokeDynamic_info 型常量结构**

| 类型 |            名称             | 数量 |
| :--: | :-------------------------: | :--: |
|  u1  |             tag             |  1   |
|  u2  | bootstrap_method_attr_index |  1   |
|  u2  |     name_and_type_index     |  1   |

bootstrap_method_attr_index 必须是当前 Class 文件中引导方法表的 bootstrap_methods[] 数组的有效索引

name_and_type_index 当前常量池的有效索引，常量池在该索引处的结构必须是 CONSTANT_NameAndType_info，表示方法名和方法描述符

**CONSTANT_Module_info 型常量结构**

| 类型 |    名称    | 数量 |
| :--: | :--------: | :--: |
|  u1  |    tag     |  1   |
|  u2  | name_index |  1   |

name_index 必须是常量池有效索引，项必须是 CONSTANT_Utf8_info，表示模块名字

**CONSTANT_Package_info 型常量结构**

| 类型 |    名称    | 数量 |
| :--: | :--------: | :--: |
|  u1  |    tag     |  1   |
|  u2  | name_index |  1   |

name_index 必须是常量池有效索引，项必须是 CONSTANT_Utf8_info，表示模块名字

### 6.3.3 访问标志

在常量池之后，是两个字节的访问标志（access_flags），用于识别一些类或者接口层次的访问信息：这个 Class 是类还是接口；是否定义为 pubic ，是否为 abstract，如果是类的话是否为 final 等等

**访问标志**

|    标志名称    | 标志值 |                     含义                     |
| :------------: | :----: | :------------------------------------------: |
|   ACC_PUBLIC   | 0x0001 |                是否为 public                 |
|   ACC_FINAL    | 0x0010 |                 是否为 final                 |
|   ACC_SUPER    | 0x0020 |  是否允许 invokespecial 字节码指令的新语义   |
| ACC_INTERFACE  | 0x0200 |                  是否为接口                  |
|  ACC_ABSTRACT  | 0x0400 | 是否为 abstract 类型，接口和抽象类此标志为真 |
| ACC_SYNTHETIC  | 0x1000 |         标识这个类并非由用户代码产生         |
| ACC_ANNOTATION | 0x2000 |               标识这是一个注解               |
|    ACC_ENUM    | 0x4000 |               标识这是一个枚举               |
|   ACC_MODULE   | 0x8000 |               标识这是一个模块               |

### 6.3.4 类索引、父类索引与接口索引集合

类索引（this_class）和父类索引（super_class）都是一个 u2 类型的数据，而接口索引集合（interfaces）是一个 u2 类型数据的集合

类索引用于确定这个类的全限定名；父类索引用于确定这个类的父类的全限定名；接口索引集合描述这个类实现了哪些接口

类索引和父类索引各自指向一个 CONSTANT_Class_info 的类描述常量

### 6.3.5 字段表集合

字段表（field_info）用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，不包括方法中的局部变量。

字段表集合不会出现从父类继承来的字段

**字段表结构**

| 类型 |       名称       | 数量 |      类型      |       名称       |       数量       |
| :--: | :--------------: | :--: | :------------: | :--------------: | :--------------: |
|  u2  |   access_flags   |  1   |       u2       | attributes_count |        1         |
|  u2  |    name_index    |  1   | attribute_info |    attributes    | attributes_count |
|  u2  | descriptor_index |  1   |                |                  |                  |

字段修饰符放在 access_flags 中

**字段访问标志**

|   标志名称    | 标志值 |           含义           |
| :-----------: | :----: | :----------------------: |
|  ACC_PUBLIC   | 0x0001 |      是否为 public       |
|  ACC_PRIVATE  | 0x0002 |      是否为 private      |
| ACC_PROTECTED | 0x0004 |     是否为 protected     |
|  ACC_STATIC   | 0x0008 |      是否为 static       |
|   ACC_FINAL   | 0x0010 |       是否为 final       |
| ACC_VOLATILE  | 0x0040 |     是否为 volatile      |
| ACC_TRANSIENT | 0x0080 |     是否为 transient     |
| ACC_SYNTHETIC | 0x1000 | 这个字段是否有编译器产生 |
|   ACC_ENUM    | 0x4000 |      字段是否 enum       |

在 access_flags 后面跟随的是 name_index 和 descriptor_index。分别是字段的简单名称以及字段和方法的描述符

简单名称是没有没有类型、没有修饰符的简单名称。例如 "private int m;" 就只剩下 "m"

描述符的作用是用来描述字段的数据类型、方法的参数列表（数量、类型、顺序）和返回值。



所有类型使用对应的大写字母标识， boolean 使用 "Z"，long 使用 “J”，对象类型使用 "L"

对于一个数组 “java.lang.String\[][]” 被描述为 "[[Ljava.lang.String"；整型数组 "int []" 被描述为 "[I"



用描述符标识方法时，先参数列表，再返回值的顺序。

"void (int [] m)" 被描述为 "([I)V"



字段表的主要信息已经结束。descriptor_index 后面还有[属性表](# 6.3.7 属性表)，存储额外信息。例如 "final static int m = 234"，就会存在一项 ConstantValue 的树型，其值指向 234

### 6.3.6 方法表集合

**方法表结构**

| 类型 |       名称       | 数量 |      类型      |       名称       |       数量       |
| :--: | :--------------: | :--: | :------------: | :--------------: | :--------------: |
|  u2  |   access_flags   |  1   |       u2       | attributes_count |        1         |
|  u2  |    name_index    |  1   | attribute_info |    attributes    | attributes_count |
|  u2  | descriptor_index |  1   |                |                  |                  |

方法表结构和字段表的结构是相同的，仅在访问标志和属性表集合的可选项上有所区别

|     标志名称     | 标志值 |             含义             |
| :--------------: | :----: | :--------------------------: |
|    ACC_PUBLIC    | 0x0001 |        是否为 public         |
|   ACC_PRIVATE    | 0x0002 |        是否为 private        |
|  ACC_PROTECTED   | 0x0004 |       是否为 protected       |
|    ACC_STATIC    | 0x0008 |        是否为 static         |
|    ACC_FINAL     | 0x0010 |         是否为 final         |
| ACC_SYNCHRONIZED | 0x0020 |     是否为 synchronized      |
|    ACC_BRIDGE    | 0x0040 | 是否为由编译器产生的桥接方法 |
|   ACC_VARARGS    | 0x0080 |      是否为接受不定参数      |
|    ACC_NATIVE    | 0x0100 |        是否为 native         |
|   ACC_ABSTRACT   | 0x0400 |       是否为 abstract        |
|    ACC_STRICT    | 0x0800 |       是否为 strictfp        |
|  ACC_SYNTHETIC   | 0x1000 |   这个字段是否有编译器产生   |

方法中的代码经过 javac 编译后存放在属性表集合的一个名为 [Code 的属性](# 6.3.7 属性表)里




### 6.3.7 属性表

每一种属性，它的名称都要从常量池中引用一个 CONSTANT_Utf8_info 类型的常量标识，属性值的结构可以完全自己定义，只需要通过一个 u4 的长度属性说明属性值所占的位数

**属性表结构**

| 类型 |         名称         |       数量       |
| :--: | :------------------: | :--------------: |
|  u2  | attribute_name_index |        1         |
|  u4  |   attribute_length   |        1         |
|  u1  |         info         | attribute_length |

**1. Code 属性**

方法体经过编译之后，最终变为字节码存储在 Code 属性中。接口和抽象类的方法不在 Code 中。

**Code 属性表结构**

|      类型      |          名称          |          数量          |
| :------------: | :--------------------: | :--------------------: |
|       u2       |  attribute_name_index  |           1            |
|       u4       |    attribute_length    |           1            |
|       u2       |       max_stack        |           1            |
|       u2       |       max_locals       |           1            |
|       u4       |      code_length       |           1            |
|       u1       |          code          |      code_length       |
|       u2       | exception_table_length |           1            |
| exception_info |    exception_table     | exception_table_length |
|       u2       |    attributes_count    |           1            |
| attribute_info |       attributes       |    attributes_count    |

attribute_name_index 是一项指向 CONSTANT_Utf8_info 型常量的索引，此常量值固定为 Code，代表了该属性的名称。

attribute_length 表示了属性值长度，由于属性名称索引和属性长度占用 6 个字节，所以真正的属性值需要减掉 6 字节

max_stack 操作数栈的最大深度。虚拟机根据此指分配栈帧中的操作栈深度

max_locals 代表了局部变量表所需要的存储空间，这里实际是变量槽数量。方法参数、显示异常处理程序的参数、方法体中定义的局部变量都需要依赖局部变量表存放。虚拟机根据同时生存的最大的局部变量数量和类型计算处 max_locals ，当一个局部变量超出作用域之后，它的局部变量槽会被其他局部变量重用。

code_length 和 code 存储原程序编译后的字节码指令。

exception_table_length 和 exception_table 是显示异常处理表，对于 Code 属性来说这个不是必须的。是 try-catch 中的异常

**异常属性表结构**

| 类型 |   名称   | 数量 | 类型 |    名称    | 数量 |
| :--: | :------: | :--: | :--: | :--------: | :--: |
|  u2  | start_pc |  1   |  u2  | handler_pc |  1   |
|  u2  |  end_pc  |  1   |  u2  | catch_type |  1   |

如果当字节码从第 start_pc 行到第 end_pc 行之间（不含 end_pc 行）出现了类型为 catch_type（指向 CONSTANT_Class_info ）或者其子类的异常，则转到第 handler_pc 行继续处理。当 catch_type 为 0 ，标识任何异常都不要处理

**2. Exceptions 属性**

这个属性和 Code 属性平级，这个时 throws 抛出的异常

**Exceptions 属性结构**

| 类型 |         名称          |         数量         |
| :--: | :-------------------: | :------------------: |
|  u2  | attribute_name_index  |          1           |
|  u4  |   attribute_length    |          1           |
|  u2  | number_of_exceptions  |          1           |
|  u2  | exception_index_table | number_of_exceptions |

number_of_exceptions 表示可能抛出 number_of_exceptions 种的受查异常，每一种使用一个 exception_index_table 项表示；exception_index_table是一个 指向 CONSTANT_Class_info 类型的索引，代表该受查异常的类型。

**3. LineNumberTable 属性**





## 6.4 字节码指令简介

Java 虚拟机采用面向操作数栈而不是面向寄存器的架构（[区别在第八章探讨](# 8 虚拟机字节码执行引擎)），所以大多数指令都不包含操作数，只有一个操作码，操作数放在操作数栈中。

Java 虚拟机操作码的长度为一个字节，意味着不能超过 256 条指令；

Class 文件格式放弃了编译后的操作数长度对齐，意味着虚拟机在处理超过一个字节的数据时，会在运行时从字节中重建出具体的结构，例如一个 16 位长度的无符号整数需要用两个无符号字节存储，这样执行字节码会损失一些性能

放弃了操作数对齐，意味着省略了大量的填充和间隔符号



### 6.4.1 字节码与数据类型

T 代表类型模板

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-Opcode.png)

大部分指令没有支持 byte , char 和 short，没有指令支持 boolean 。编译器在编译期或运行期间将 byte 和 short 类型的数据带符号扩展为对应的 int 类型，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据





### 6.4.2 加载和存储指令

- 将一个**局部变量加载到操作栈**：iload , iload\_<n\> , lload , lload\_<n\> ,  , fload , fload\_<n\> , dload , dload\_<n\> , aload , aload_<n\>
- 将一个数值从**操作数栈存储到局部变量表**：istore , istore\_<n\> , lstore , lstore\_<n\> , fstore , fstore\_<n\> , dstore , dstore\_<n\> , astore , astore\_<n\> 
- 将一个**常量加载到操作数栈**：bipush , sipush , ldc , ldc_w , ldc2_w , aconst_null , iconst_ml , inconst\_<i\> , lnconst\_<l\> , fnconst\_<f\> , dnconst\_<d\>
- 扩充局部变量表的访问索引的指令：wide

存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作。除此之外，还有访问对象字段或数组元素的指令也会向操作数栈传输数据





### 6.4.3 运算指令

- 加法指令：(i,l,f,d) add，即 iadd , ladd , fadd , dadd
- 减法指令：(i,l,f,d) sub
- 乘法指令：(i,l,f,d) mul
- 除法指令：(i,l,f,d) div
- 求余指令：(i,l,f,d) rem
- 取反指令：(i,l,f,d) neg
- 位移指令：ishl , ishr , iushr , lshl , lshr , lushr
- 按位或指令：ior , lor
- 按位与指令：iand , land
- 按位异或指令：ixor , lxor
- 局部变量自增指令：inc
- 比较指令：dcmpg , dcmpl , fcmpg , fcmpl , lcmp

求余指令和除法指令当除数为 0 时，虚拟机会抛出 ArithmeticException 异常

浮点数符合 IEEE 754 规范



### 6.4.4 类型转换指令

宽化转化不需要显式的表示出来

窄化转化需要明确的指出

- i2b , i2c , i2s , l2i , f2i , d2i , d2l , d2f

窄化类型转换可能会导致结果产生不同的正负号、不同数量级的情况，可能产生精度丢失

将 int 或 long 类型窄化处理为整数类型 T 的时候，转换过程仅仅是丢掉最低 N 位以外的内容，N 是 T 类型数据的长度，原来的符号位被丢弃，新的符号只能随缘

窄化转化为整数类型 T （int 或 long）时，必须遵循以下原则：

- 如果浮点数是 NaN，那转化结果就是 0
- 如果不是无穷大的话，遵循 IEEE 754 的像零舍入模式取整。如果在对应目标的范围内，则获得该数，如果超过该范围，那将根据这个数的符号转化为 T 所能表示的最大或最小正数



### 6.4.5 对象创建与访问指令

- 创建类实例：new
- 创建数组指令：newarray , anewarray , multianewarray
- 访问类字段（static 字段）和实例字段（非 static 字段）：getfield , putfield , getstatic , putstatic
- 把**一个数组元素加载到操作数栈的指令**：balod , caload , saload , iaload , laload , faload , daload , aaload
- 将**一个操作数栈的值存储到数组元素**的指令：bastore , castore , sastore , iastore , fastore , dastore , aastore
- 取数组长度指令：arraylength
- 检查类实例类型的指令：instanceof , checkcast



### 6.4.6 操作数管理指令

- 将操作数栈的栈顶一个或两个元素出栈：pop , pop2
- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压栈：dup , dup2 , dup_x1 , dup2_x1 , dup_x2 , dup2_x2
- 将栈顶最顶端的两个元素交换：swap

### 6.4.7 控制转移指令

有条件或无条件的从指定位置的（修改 PC 寄存器的值）下一条指令继续执行

- 条件分支指令：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnotnull、if_icmpeq、if_icmpeq、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_icmpeq和ic-icmpne.
- 符合条件分支：tableswitch、lookupswitch
- 无条件分支：goto、goto_w、jsr、jsr_w、ret

boolean ， byte ，char，short 类型的条件分支操作，都会使用 int 类型的比较指令完成，对于 long ，float， double 类型则先会执行[比较运算指令](# 6.4.3 运算指令)，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作完成分支跳转

### 6.4.8 方法调用和返回指令

[方法调用](# 8.3 方法调用)在第八章进行讲解

- invokevirtual指令：用于调用对象实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java最常见的方法分派。
- invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口的方法对象，找出合适的方法进行调用。
- invokespecial：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
- invokestatic：用于调用静态方法
- invokeddynamic：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法

- 返回指令：ireturn , lreturn , freturn , dreturn , areturn

### 6.4.9 异常处理指令

显式抛出异常（throws 关键字）都由 athrow 指令实现

其他异常（catch 语句）使用异常表实现

### 6.4.10 同步指令

Java 虚拟机支持方法级同步和方法内部一段指令序列同步，这样中同步方法都是用**管程（Monitor，就是 锁）**来实现

如果一个同步方法在执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程（Monitor）将在异常抛到同步方法边界之外时自动释放。

- monitorenter：获得锁

- monitorexit：释放锁

  

# 7 虚拟机类加载机制

## 7.2 类的加载时机

虚拟机类加载的七个阶段

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-Loading.png)

[解析](# 7.3.4 解析)阶段有可能会在初始化阶段之后进行。

对于[初始化](# 7.3.5 初始化)阶段，在下面六种情况的时候必须开始（[加载](# 7.3.1 加载)、[验证](# 7.3.2 验证)、[准备](# 7.3.3 准备)阶段必然在这之前）：

1. 遇到 new、getstatic、putstatic 或者 invokestatic 这四条字节码指令的时候，如果类型没有初始化就需要先初始化。能够生成这四条指令的场景：
   - 使用 new 关键字实例化对象
   - 读取或设置一个类型的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候
   - 调用一个类型的静态方法的时候
2. 使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类
5. 当使用 JDK 7 新加入的动态语言支持时，入宫一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化
6. 当一个接口定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那接口要在其之前被初始化

只有上面六种**主动引用**的情况才会触发类的初始化

**被动引用**是不会触发初始化的

**被动引用一**

```java
//通过子类引用父类的静态字段，不会导致子类初始化

//父类定义
public class SuperClass {
    static {
        System.out.println("superClass init");
    }

    public static int value = 123;
}

//子类定义
public class SubClass extends SuperClass {
    static {
        System.out.println("subClass init");
    }
}

//测试
public class NoInitialization {
    public static void main(String[] args){
        System.out.println(SubClass.value);
    }
}

//输出
//superClass init
//123
```

子类的加载和验证是否进行取决于 Java 虚拟机的实现



**被动引用二**

```java
//通过数组定义来引用类，不会触发此类的初始化
//测试
public class NoInitialization {
    public static void main(String[] args){
        SuperClass[] sca = new SuperClass[10];
        System.out.println(sca.length);
    }
}

//输出
//10 数组长度

public class NoInitialization {
    public static void main(String[] args){
        SuperClass[] sca = new SuperClass[10];
        System.out.println(sca[0].value);//对元素对象进行引用时，就会触发初始化
    }
}
//输出
//superClass init
//123
```

上面第一个测试会触发一个由虚拟机自动生成的类的初始化，直接继承于 java.lang.Object ，创建动作由 anewarray 触发。



**被动引用三**

```java
//常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

//定义常量的类
public class ConstClass {
    static {
        System.out.println("constClass init");
    }

    public static final String HELLOWORLD = "hello world";
}

//调用类
public class NoInitialization {
    public static void main(String[] args){
       System.out.println(ConstClass.HELLOWORLD);
    }
}

//输出
//hello world
```

在编译阶段，Java 虚拟机已经将常量保存到了 NoInitialization 类的常量池中，以后对 ConstClass.HELLOWORLD 的引用，实际都被转化为 NoInitialization 常量的引用。NoInitialization 中不存在 ConstClass 类的符号引用入口，这两个类在编译完成后就没有任何关系了。



接口的加载过程与类的加载过程稍有不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的。接口中不能使用 static{} 输出初始化信息，但是编译器仍然会为接口生成一个 “<clinit\>()” 类构造器，用于初始化接口中所定义的成员变量。

接口与类真正有区别的是六种触发场景前面第三种情况：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部完成初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

## 7.3 类加载过程

### 7.3.1 加载

加载阶段虚拟机需要完成三件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据接结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

Java 虚拟机规范并没有给第一条进行很多限制，没有限制必须从某个 Class 文件中获取二进制字节流。因此可以有多种方式：从 ZIP 压缩包中获取、从网络中获取等等。

**非数组类型**

相对于类加载过程的其他阶段，非数组类型的加载阶段（加载阶段获取二进制字节流的动作）是开发人员可控性最强的阶段。加载阶段可以有 Java 虚拟机内置的启动类加载器完成，也可以由用户自定义的类加载器完成，开发人员通过**自定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的 findClass() 或 loadClass() 方法）**，现在根据自己的想法来赋予应用程序获取运行代码的动态性。

**数组类型**

数组类不通过类加载器创建，由 Java 虚拟机直接在内存中动态构造出来。但是数组去掉所有维度之后，还是需要类加载器来完成加载，一个数组类创建的过程遵循以下规则：

- 如果数组的组件类型（数组去掉一个维度的类型，不是元素类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件，**数组将被标识在加载该组件类型的类加载器的类名称空间上（[类加载器](# 7.4 类加载器)）**

- 如果数组的组件不是引用类型（int[] 的组件类型为 int），java 虚拟机将会把数组标记为与启动类加载器关联
- 数组类的可访问性与他的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组可访问性将默认为 public

加载阶段结束之后，二进制字节流就会存储到[方法区](# 2.2 运行时数据区)中。虚拟机会在堆内存中实例化一个 java.lang.Class 类对象，作为程序访问方法区中的类型数据和外部接口。

### 7.3.2 验证

这个阶段验证确保 Class 文件的字节流包含的信息符合 Java 虚拟机规范的全部要求。

验证阶段有四个检验动作：**文件格式验证、元数据验证、字节码验证和符号引用验证**

**1. 文件格式验证**

该阶段验证字节流是否符合 Class 文件规范，并且能被当前版本的虚拟机处理，可能包括下面的验证点：

- 验证[魔数](# 6.3.1 魔数与 Class 文件的版本)
- 主次版本号是否在当前版本虚拟机接受范围内
- [常量池](# 6.3.2 常量池)中的常量是否有不支持的类型（检查常量 tag）
- 指向常量的各种索引值是否有只想不存在的常量或不符合类型的常量
- [CONSTANT_Utf8_info](# 6.3.2 常量池) 中是否有不符合 UTF-8 类型的数据
- Class 文件中各个部分及文件本身是否又被删除的或附件的其他信息
- 。。。

该阶段的主要目的是保证字节流能够正确的解析并存储到方法区里

**2. 元数据验证**

对字节码描述的信息进行语义分析，保证符合 Java 语言规范，可能包含的验证点：

- 这个类是否有父类（除了 java.lang.Object 之外都应该有父类）
- 这个类的父类是否继承了不允许被继承的类（ final 修饰类）
- 如果是抽象类，是否实现了所有父类或接口中要求实现的方法
- 。。。

**3. 字节码验证**

主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的，确保不会做出危害虚拟机安全的行为

- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作（不会出现 “在操作数栈放置了一个 int 类型数据，使用时却按照 long 类型加载入本地变量表”）
- 保证任何跳转指令都不会跳到方法体以外的字节码指令上
- 。。。

**4. 符号引用验证**

发生在虚拟机将[符号引用转化为直接引用](# 7.3.4 解析)的时候，这个转化动作将在连接的第三个阶段——[解析](# 7.3.4 解析)中发生。符号引用验证可以看作是对类自身意外的各类信息进行匹配校验（该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源）

- 符号引用中通过字符串描述的全限定名是否能找到对应的类
- 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
- 符号引用中的类、字段、方法的可访问性（private、protected、public、<package\>）是否可被当前类访问
- 。。。

在生产环境中可以使用 -Xverify:none 来关掉验证。



### 7.3.3 准备

该阶段正式为类中定义的变量（即静态变量）分配内存并设置类变量初始值（不同于开发过程的初始值，准备阶段过后，还未执行任何方法）的阶段。

这个阶段进行内存分配仅包括类变量，不包括实例变量，实例变量会在对象实例化时随着对象一起分配在 Java 堆中

```java
public static int value = 123;
```

该语句，在准备阶段过后的初始值为 0 .因为这个时候还没有开始执行任何 Java 方法，而把 value 赋值为 123 的 putstatic 指令是在程序被编译后，存放于类构造器 <clinit\>() 方法中，赋值阶段需要在这个方法调用时进行。

如果是下面的 ConstantValue 属性

```java
 public static final int value = 123;
```

这会在准备阶段就为 value 初始化为 123

### 7.3.4 解析

解析阶段虚拟机将常量池内的符号引用替换为直接引用的过程（将二进制字节码流转化为真是内存地址）。

- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标就可以。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存的内容。各种虚拟机实现的内存布局可能不同，但是能够识别的符号引用必须符合规范，因为符号引用的字面量形式已经有明确定义。
- 直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的。

解析的时机只要求在：anewarray , checkcast , getfield , instanceof , invokedynamic , invokeinterface , invokespecial , invokestatic , invokevirtual , ldc , ldc_w , ldc2_w , multianewarray , new , putfield , putstatic 指令之前，先对它们所使用的符号引用进行解析。

虚拟机可以决定是加载阶段就对符号引用进行解析还是在将要使用时再进行解析。

对方法、字段的访问，也会在解析阶段中对它们的可访问性进行检查

虚拟机实现可以对一个符号引用的解析进行缓存（不包括 invokedynamic 指令），当第二次请求时，直接从缓存中取结果。



解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定这 7 类符号引用。



**1. 类或接口的解析**

假设当前代码所处的类 D，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，需要完成下面三个步骤：

1. 如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载 C 。加载过程会触发其他相关类的加载过程，一旦出现任何问题都会解析失败。
2. 如果 C 是一个数组类型，并且数组的元素类型为对象，也就是 N 的描述符是类似 "[Ljava/lang/Integer]" 的形式，那将会按照第一点的规则加载，接着虚拟机生成一个代表该数组为度和元素的数组类型。
3. 如果上面没有出现异常，那么 C 已经成为一个有效的类或接口了，但是解析完成前还需要进行[符号引用验证](# 7.3.2 验证)，确认 D 是否具备对 C 的访问权限。如果不具备权限，将抛出 java.lang.IllegalAccessError 异常

JDK 9 引入模块话概念后，满足下面任一条，我们认为 D 拥有 C 的访问权限：

- 被访问类 C 是 public，并且与 D 处于同一模块
- 被访问类 C 是 public，与 D 不处于同一模块，但是被访问类 C 的模块允许访问类 D 的模块进行访问
- 被访问类 C 不是 public，但是它与访问类 D 处于同一个包中

**2. 字段解析**

解析一个未被解析过的字段符号引用，首先将会对[字段表内的 class_index（CONSTANT_Fieldref_info 型常量结构）](# 6.3.2 常量池)项中的索引 CONSTANT_Class_info 符号引用进行解析，也就是字段所属的类或接口的符号引用。这个过程出现异常就会失败。如果解析完成，将该字段所属的类或接口用 C 表示，要求按照下面的步骤进行后续字段的搜索：

1. 如果 C 本身就包含了[简单名称和字段描述符](# 6.3.5 字段表集合)都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
2. 否则，如果 C 中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父类接口，如果接口中包含了[简单名称和字段描述符](# 6.3.5 字段表集合)都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3. 否则，如果 C 不是 java.lang.Object 的话，将会展昭继承关系从下往上递归搜索其父类，如果接口中包含了[简单名称和字段描述符](# 6.3.5 字段表集合)都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4. 否则，查找失败（本身、父类接口、父类类都找过了），抛出 java.lang.NoSuchFieldError 异常。

如果查找过程成功返回了引用，就会对这个引用进行权限验证，不具备权限将抛出 java.lang.IllegalAccessError 异常

**3. 方法解析**

方法解析首先需要解析出[字段表内的 class_index（CONSTANT_Methodref_info 型常量结构）](# 6.3.2 常量池)项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用 C 表示这个类，接下来虚拟机将按照下面的步骤进行搜索：

1. 在类的方法表发现 class_index 中索引的 C 是个接口的话，直接抛出 java.lang.IncompatibleClassChangeError 异常
2. 如果通过了第一步，在类 C 中查找是否有简单名称和描述符都与目标匹配的方法，如果有，查找结束
3. 否则，在类 C 的父类中递归查找，如果匹配则结束
4. 否则，在类 C 实现的接口列表及它们的父接口中递归查找，如果有说明类 C 是一个抽象类，这时候查找结束，抛出 java.lang.AbstractMethodError 异常
5. 否则，宣告方法查找失败，抛出 java.lang.NoSuchMethodError 异常

如果查找过程成功返回了引用，就会对这个引用进行权限验证，不具备权限将抛出 java.lang.IllegalAccessError 异常

**4. 接口方法解析**

接口方法需要先解析出接口方法表的 [class_index （CONSTANT_InterfaceMethodref_info 型常量结构）](# 6.3.2 常量池)项中的索引的方法所属的类或接口的符号引用，如果解析成功，我们用 C 来表示，虚拟机将会按照下面的步骤进行搜索：

1. 在接口的方法表发现 class_index 中索引的 C 是个类的话，直接抛出 java.lang.IncompatibleClassChangeError 异常
2. 否则，在接口 C 中查找是否有简单名称和描述符都与目标匹配的方法，如果有则返回引用，查找结束
3. 否则，在接口 C 的父接口中递归查找，直到 java.lang.Object 类（包括 Object 中的方法）为止，是否有简单名称和描述符都与目标匹配的方法，如果有则返回引用，查找结束
4. 对于规则 3 ，Java 接口允许多继承，如果 C 的不同父接口中存在多个简单名称和描述符都与目标匹配的方法，那将从这多个方法中返回一个结束查找
5. 否则，宣告方法查找失败，抛出 java.lang.NoSuchMethodError 异常

在 JDK 9 之前不存在模块化，所有接口的方法都是 public，不存在访问权限问题。JDK 9 之后增加了接口的静态私有方法，也有了模块化的访问约束，可能抛出 java.lang.IllegalAccessError 异常。

### 7.3.5 初始化

初始化阶段就是执行类构造器 <clinit\>() 方法的过程。



- <clinit\>() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生，收集顺序由语句在源文件中出现的顺序决定，静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量不能访问，但是可以进行赋值操作

```java
public class FieldResolution {
    static {
        i = 1;//可以赋值
//        System.out.println(i);//非法前向引用
    }

    static int i = 0;//必须是静态的
}	
```

- <clinit\>() 方法与类的构造函数（虚拟机中就是 <init\>()）不同，它不需要显式的调用父类构造器。虚拟机会保证子类的 <clinit\>() 在父类的 <clinit\>() 之后调用
- 父类的 <clinit\>() 方法先执行，那么父类的静态语句块要优先于子类的的变量赋值操作

```java
static class Parent {
    public static int a = 1;

    static {
        a = 2;
    }
}

static class SubClass extends Parent {
    public static int b = a;
}

public static void main(String[] args) {
    System.out.println(SubClass.b);//输出 2
}
```

- <clinit\>() 方法对于类或接口来说不是必须的，**如果没有静态语句块也没有变量赋值操作，就不会有 <clinit\>() 方法**
- 接口没有静态语句块，但是会有变量赋值操作，因此会有 <clinit\>() 方法。但是接口执行 <clinit\>() 方法不需要先执行父接口的 <clinit\>() 方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化，**接口的实现类在初始化时，也不会执行接口的 <clinit\>() 方法**。

- <clinit\>() 方法是同步的

## 7.4 类加载器

把实现[加载阶段](7.3.1 加载)的 “通过一个类的全限定名来获取定义此类的二进制字节流” 这个动作的代码称为 “类加载器（Class Loader）”

### 7.4.1 类与类加载器

对于任意一个类，都必须由加载它的类加载器和它本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。在比较两个类相等（equlas() 方法，isAssignableFrom() 方法，isInstance() 方法的返回结果，instanceOf 的判定）时，即使这两个来自同一个 Class 文件，只要加载器不同，它们也是不同的

### 7.4.2 双亲委派机制

对于 Java 虚拟机来说，只存在两种类加载器：一种是启动类加载器（Bootstrap ClassLoader，由 C++ 实现，是虚拟机的一部分），另一个是其他所有类的加载器，这些类加载器由 Java 语言实现，独立于虚拟机外，均继承自抽象类 java.lang.ClassLoader 

JDK 8 以前 Java 保持着三层类加载器、双亲委派机制加载架构，到了 JDK 9 的模块化后稍有不同

- 启动类加载器：**负责加载存放在 <JAVA_HOME\>\lib 目录**，或者**被 -Xbootclasspath 参数所指定的路径**中存放的，而且是 Java 虚拟机能够识别的类库加载到虚拟机的内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器去处理，那直接使用 null 替代即可。
- 扩展类加载器：这个类加载器在类 sun.misc.Launcher$ExtClassLoader 中以 Java 代码的形式实现的。**负责加载 <JAVA_HOME\>\lib\\ext目录**中，或者**被 java.ext.dirs 系统变量所指定的路径**中所有的类库。可以直接在程序中使用这个加载器。
- 应用程序类加载器：这个类加载器在类 sun.misc.Launcher$AppClassLoader 中以 Java 代码的形式实现的。由于应用程序类加载器是 ClassLoader 类中的 getSystemClassLoader() 方法的返回值，所以也称为 “系统类加载器”。它负责**加载用户类路径（ClassPath）上所有的类库**，开发者同样可以直接在代码中使用这个类加载器。如果没有自定义类加载器，这个一般就是默认的。

**类加载器的双亲委派机制模型**

通过自定义类加载器（重写 findClass()），可以增加除了磁盘位置之外的 Class 文件来源，或者实现类的隔离、重载等功能

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png)

各种类加载器之间的层次关系被称为 “双亲委派模型（Parent Delegation Model）”。

双亲委派模型要求除了启动类加载器外，其他类加载器都应该有自己的父类加载器。类加载器之间的父子关系一般不以继承的关系来实现，而通常以组合（Composition）关系来复用父类加载器的代码。

**双亲委派机制的工作过程：**如果一个类加载器收到了类加载请求，它首先不会自己进行加载，而是把这个请求委派给自己的父类加载器完成，每一个层次都是这样。最后会传递到最顶层的启动类加载器中，当父类加载器反馈自己无法完成这个加载请求（搜索范围中没有找到所需要的类），子加载器才会自己尝试加载。

使用双亲委派机制可以保证一个类被加载出来是相同的：java.lang.Object ，存放在 tr.jar 中，无论是哪一个类加载器都要加载这个类，最终都是委派给模型顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都能保证是同一个类。这样使得 Java 类随着它的类加载器一起具备了层次关系。

**优势**

防止重复加载同一个 .class 文件，如果加载过了就不会再被加载。保证核心的 .class 不会被篡改，即使篡改也不会加载，即使加载也与核心的 .class 不同，保证了核心 .class 的安全

```java
package java.lang;

public class String {
    static{
        System.out.println("我是自定义的String类的静态代码块");
    }
}
```

```java
public class StringTest {

    public static void main(String[] args) {
        java.lang.String str = new java.lang.String();
        System.out.println("hello,atguigu.com");
    
        StringTest test = new StringTest();
        System.out.println(test.getClass().getClassLoader());//输出 sun.misc.Launcher$AppClassLoader
    }

}
```

我们自己写的 String 类，本来应该是应用程序类加载器进行加载，由于双亲委派机制，这个加载请求一直向上传导，最终交给了启动类加载器，启动类加载器发现是 java.lang.String ，它执行了它实现的该类的加载流程，也就是 JDK 自带的 String

**双亲委派模型实现**

```java
public class FieldResolution {
    protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        //首先检查请求的类是否已经被加载过
        Class c = findLoadedClass(name);
        if (c == null) {
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);//父类加载器
                } else {
                    c = findBootstrapClassOrNull(name);//交给启动类加载器
                }
            } catch (ClassNotFoundException e) {
                //如果父类加载器抛出 ClassNotFoundException
                //说明父类无法完成加载请求
            } finally {
                //父类无法加载是
                //再调用本身的findClass方法进行类加载
                c = findClass(name);
            }
        }
        if (resolve) {
            return resolveClass(c);
        }
        return c;
    }
}
```



### 7.4.3 破坏双亲委派模型

第一次破坏：JDK 1.2 之前没有双亲委派模型的概念，用户自定义类加载器时会重写 loadClass()，导致并不会委派给父类加载器。后来加入了双亲委派机制，引导用户在 findClass() 中实现自定义的类加载器

第二次破坏：JNDI 调用其他厂商实现并步数在应用程序的 ClassPath 下的 JNDI 服务提供者接口的代码。引入线程上下文类加载器解决这个问题。这个类加载器通过 java.lang.Thread 类的 setContextClassLoader() 方式进行设置，如果创建线程时还没有进行设置，他会从父类线程中继承一个，如果应用程序全局都没有设置，这个类加载器就会默认为应用程序类加载器。JNDI 服务使用这个线程上下文类加载器去加载 SPI 代码，这是一种父类加载器请求子类加载器完成类加载的行为。JDK 6 中提供了 java.util.ServiceLoader 类，以 META-INF/services 中的配置信息，配合责任链模式提供了一个相对合理的解决方案。

第三次破坏：用户追求代码动态性导致（代码热替换，模块热部署）。

OSGi 模块化热部署的关键是它的自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再双亲委派机制推荐的树状结构，而是进一步发展为了网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：

1. 将以 java.* 开头的类，委派给父类加载器加载
2. 否则，将委派列表名单内的类，委派给父类加载器加载
3. 否则，将 Import 列表内的类，委派给 Export 这个类的 Bundle 的类加载器加载
4. 否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载
5. 否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Frament Bundle 的类加载器加载
6. 否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载
7. 否则，类查找失败。

前两点符合双亲委派，其余的都是在平级的类加载器中进行



## 7.5 Java 模块化系统

模块化目标——可配置的封装隔离机制

Java 模块定义还包括下面的内容：

- 依赖其他模块的列表
- 导出的包列表，即其他模块可用的列表
- 开放的包列表，即其他模块可反射访问模块的列表
- 使用的服务列表
- 提供服务的实现列表

可配置的封装隔离机制**首先要解决类路径（ClassPath）来查找依赖可靠性问题**。JDK 9 以后，如果启用了模块化进行封装，模块就可以声明对其他模块的显式依赖，这样 Java 虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系，不完备直接启动失败。JDK 9 之前只能等到运行到发生该类型的加载、链接时才会报出运行异常。

还解决**原来类路径上跨 JAR 文件的 public 类型的可访问性问题。**JDK 9 中的 public 类型不再意味着程序的所有地方的代码都可以随意访问它们，模块提供了更精细化的可访问控制，必须声明其中哪一些 public 的类型可以被其他哪一些模块访问，这种访问控制也主要在[类加载过程中完成（类或接口的解析）](# 7.3.4 解析)

### 7.5.1 模块的兼容性

JDK 9 提出了 模块路径（ModulePath）“ 的概念，使得可配置封装隔离机制能够兼容传统的类路径查找。某个类库到底是模块还是 JAR 包，取决于它放在哪个路径上。

模块化系统将按照下面的规则保证传统类路径依赖的 Java 程序可以不经修改地直接运行在 JDK 9 及以后的 Java 版本上。

- JAR 文件在类路径的访问规则：所有类路径下的 JAR 文件及其他资源文件，都被视为自动打包在一个匿名模块里，这个匿名模块几乎没有任何隔离，它可以看到和使用类路径上所有的包、JDK 系统模块中所有的导出包，以及模块路径上所有模块导出的包
- 模块在模块路径的访问规则：模块路径下的具名模块只能访问到它依赖定义中列明依赖的模块的包，匿名模块（JAR 类路径）里所有的内容对具名模块来说都是不可见的，即具名模块看不见传动JAR 包的内容
- JAR 文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的 JAR 文件放置到模块路径上中，它就会变成一个自动模块。尽管不包含 module-info.class，但自动模块将默认依赖于整个模块路径中所有模块，因此可以访问到所有模块导出的包，自动模块也将默认导出自己所有的包。



### 7.5.2 模块下的类加载器

扩展类加载器被平台类加载器（Platform Class Loader）取代；

平台类加载器和应用程序类加载器都不再派生自 java.net.URLClassLoader，现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader；

JDK 9 仍然维持着三层类加载器和双亲委派架构，但委派关系发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到归属关系，就要优先委派给负责那个模块的加载器完成加载（可以算是第四次破坏）

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-jdk9classLoader.png)



# 8 虚拟机字节码执行引擎



## 8.2 运行时栈帧结构

**栈帧（Stack Frame）**是用于支持虚拟机进行方法调用和方法执行背后的数据结构，也是 虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。

在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到放发表的Code属性中



### 8.2.1 局部变量表

局部变量表（Local Variables Table）是以组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在编译期就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。



### 8.2.2 操作数栈

操作数栈（Operand Stack）也常被称为操作数栈，它是一个后入先出栈。在编译期就会确定操作数栈的最大深度，写入到Code属性的max_stacks数据项中。



### 8.2.3 动态链接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接（Dynamic Linking）。字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为**静态解析。**另外一部分将在每一次运行期间转化为直接引用，这部分称为**动态链接。**在下一节中详解。



### 8.2.4 方法返回地址

当一个方法开始执行后，只有两种方式退出这个方法。

第一种方法是执行引擎遇到任意一个方法返回的字节码指令，这个时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令决定，这种退出方式为 **正常调用完成**

另一种退出方式是执行过程中遇到一场，并且这个异常没有在方法体内处理，这种被称为 **异常调用完成**

无论是哪种退出方式，在退出后都必须回到最初方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。方法正常退出时，主调方法的PC计数器的值可以作为返回地址（返回到主调方法），栈帧中可能保存这个计数器的值。异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。

方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调正PC计数器的值以指向方法调用指令后面的一条指令等。



### 8.2.5 附加信息

## 8.3 方法调用

方法调用不等同于方法中的代码被执行，**方法调用阶段唯一的任务就是确定被调用方法版本（调用哪一个方法）**，暂时还没涉及到方法内部的具体运行过程。

### 8.3.1 解析

所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。这种解析能够成立的前提是，方法在程序中真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不会改变的，换句话说，调用目标在程序代码写好、编译期进行编译的那一刻就确定下来了，这类方法的调用被称为解析。

静态方法和私有方法只有一个确定的版本，符合上面的过程。静态方法直接与类关联，私有方法在外部不能被访问，这两种方法的特点决定了它们不可能通过继承或别的方式重写其他的版本。

- invokestatic：用于调用静态方法
- invokespecial：用于调用实例构造器<init\>()方法、私有方法和父类中的方法
- invokevirtual：用于调用所有的虚方法
- invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象
- invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，再执行该方法

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本。java中符合这个条件的方法有：静态方法、私有方法、实例构造器、父类方法，另外还有final修饰的方法（能够被invokevirtual调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用，这些方法统称为 **非虚方法（Non-Virtual Method）**，其他的方法被称为 **虚方法（Virtual Method）**

解析调用是一个静态的过程，在编译期间就完全确定，在类加载解析阶段就会把设计的符号引用全部转变为明确的直接引用

另一种方法调用方式称为：分派（Dispatch），它可能是静态的也可能是动态的，还分为单分派和多分派



### 8.3.2 分派

**1. 静态分派**

针对重载

```java
public class Main {
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        sayHello(man);//输出 Hello,guy
        sayHello(woman);//输出 Hello,guy
    }
    static abstract class Human{ }
    static class Man extends Human{ }
    static class Woman extends Human{ }

    public static void sayHello(Human guy){
        System.out.println("Hello,guy");
    }
    public static void sayHello(Man man){
        System.out.println("Hello man");
    }
    public static void sayHello(Woman woman){
        System.out.println("Hello woman");
    }
}
```

上面的代码为什么执行的是`Human guy`的重载版本？

> Human man = new Man()

上面的代码中的 `Human` 称为变量的**静态类型（Static Type）**，或者叫做**外观类型(Apparent Type)**，后面的 `Man` 称为变量的**实际类型（Actual Type）**或者叫**运行时类型（Runtime Type）**。

静态类型和实际类型在程序中都可能会发生变化，区别时静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译期在编译程序的时候并不知道一个对象的实际类型是什么。

**虚拟机在调用重载方法的时候是根据静态类型进行调用的，而不是根据实际类型。**由于静态类型在编译阶段是可知的，所以在编译时，就会选择 `sayHello(Human)` 作为调用目标，并把这个方法的符号引用写到 main() 方法里的两条 invokevirtual 指令的参数中。

所有依赖静态类型来决定方法执行版本的分派动作，被称为 **静态分派**。



**2. 动态分派**

针对覆盖重写

```java
public static void main(String[] args) {
    Human man = new Man();
    Human woman = new Woman();
    man.sayHello();//Hello man
    woman.sayHello();//Hello woman
    man = new Woman();
    man.sayHello();//Hello woman
}
static abstract class Human{
    protected abstract void sayHello();
}
static class Man extends Human{
    @Override
    protected void sayHello(){
        System.out.println("Hello man");
    }
}
static class Woman extends Human{

    @Override
    protected void sayHello() {
        System.out.println("Hello woman");
    }
}
```

> ```java
> public static void main(java.lang.String[]);
> Code:
> Stack=2,Locals=3,Args_size=1
> 0:new #16; //class org/fenixsoft/polymorphic/DynamicDispatch$Man
> 3:dup
> 4:invokespecial #18; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Man."<init>":()V
> 7:astore_1
> 8:new #19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman
> 11:dup
> 12:invokespecial #21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman."<init>":()V
> 15:astore_2
> 16:aload_1
> 17:invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
> 20:aload_2
> 21:invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
> 24:new #19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman
> 27:dup
> 28:invokespecial #21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman."<init>":()V
> 31:astore_1
> 32:aload_1
> 33:invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
> 36:return
> ```

0~15行作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表的变量槽中，这些动作实际对应了Java中的两行

```
Human man = new Man();
Human woman = new Woman();
```

16和20行的aload指令分别把刚创建的两个对象引用压到栈顶，这连个对象是将要执行sayHello()方法的所有者，称为接收者（Receiver）；17\~21行是方法调用指令，这两条指令从字节码角度看指令（invokevirtual）和参数（#22）都是一样的，但是这两句指令却执行了不同的方法。

invokevirtual指令的运行时解析过程大致如下：

1. 找到操作数栈顶的第一个元素所指向的对象的**实际类型**，记作C
2. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常
3. 否则，按照继承关系从下往上一次对C的各个父类进行第二步的搜索和验证过程
4. 如果始终都没有找到合适的方法，则抛出java.lang.AbstractMethodError异常

因此，这样调用只对方法有效，对字段无效，因为字段并不使用这条指令（这也算是为什么在多态调用的时候，执行方法看等号右边，调用变量看等号左边）



**3. 单分派与多分派**



**4. 虚拟机动态分派的实现**

动态分派在各种虚拟机中实现的机制会有差别，但是一种基础且常见的手段是为类型在方法区中建立一个虚方法表（Virtual Method Table，invokeinterface执行时也有对应的Interface Method Table），使用虚方法表索引来代替元数据查找以提高性能。



虚方法表中存放着各个方法的实际入口地址，如果这个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同，如果重写，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。

为了方便，具有相同签名的方法，在父类和子类的虚方法表中具有同样的索引号，这样当类型变换时，只需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需要的入口地址。虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化。



## 8.4 动态类型语言支持

1.7 新增 invokedynamic 指令

### 8.4.1 动态类型语言

动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的





# 10 前端编译与优化



# 11 后端编译与优化

## 11.2 即时编译器

### 11.4.3 逃逸分析

逃逸分析的基本原理：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为 **方法逃逸**；甚至还有可能被外部线程访问，例如赋值给可以在其他线程中访问的实例变量，称为 **线程逃逸**；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。

如果能够确定一个对象不会逃逸到方法或者线程外（别的方法和线程无法通过任何途径访问到这个对象），或者逃逸程度较低（只逃逸出方法而不会逃逸出线程），则可能作出下列优化：

- **栈上分配（Stack Allocations）：**Java堆上分配创建对象的内存空间，堆中的对象对于各个线程是共享和可见的，只要持有这个对象的引用就能访问到堆中存储的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都要消耗大量的资源。**如果确定一个对象不会逃逸到线程之外，那让这个对象在栈上分配内存将会是一个很不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。**在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能够使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。**栈上分配可以支持方法逃逸，不支持线程逃逸。**
- **标量替换（Scalar Replacement）：**若一个数据已经无法再分解成更小的数据来表示了，java虚拟机中的原始类型（基本数据类型和reference类型）都不能再进一步分解了，那么这些数据就可以被称为**标量**。相对的，如果一个数据可以继续分解，那它就被称为**聚合量**，Java中的对象就是典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为**标量替换**。**假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候可能不去创建这个对象，而是改为直接创建它的若干个被这个方法使用的成员变量来代替。**将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整的结构分配），但对逃逸程度的要求更高，**不允许逃逸出方法范围内。**
- **同步消除（Synchronized Elimination）：**线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会存在竞争，对这个变量实施的同步措施也就可以安全地消除掉（锁消除）。







# 12 Java 内存模型与线程

## 12.1  概述

## 12.2 硬件的效率与一致性

因为CPU的读写速度十分快，比内存和硬盘高几个数量级，为了使得CPU发挥出更好的性能，现代计算机模型加入了缓存（Cache），这同时又出现了一个问题，即 **缓存一致性问题（Cache Conherence）**，在多路处理器中，每个处理器又都有自己的高速缓存，它们都共享同一主存。

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-Cache.png)

当多个处理器的运算任务都涉及到同一块主存区域时，将可能导致各自的缓存数据不一致，从高速缓存同步回主存时该以谁的为准？

除了增加高速缓存之外，处理器可能会对输入代码进行指令重排，处理器将会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果一致，但并不保障程序中间各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的顺序来保证。

## 12.3 Java内存模型

Java内存模型（JMM）

### 12.3.1 主内存与工作内存

Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。这里的变量包括实例字段、静态字段和构成数组对象的元素（堆区，共享）但是不包括局部变量和方法参数（虚拟机栈，线程私有，不共享）

Java内存模型规定了所有的变量都存储在主存上（这里的主存是指虚拟机内存的一部分）

**每条线程都有自己的工作内存（可以类比物理机的高速缓存），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的数据。**也就是这里才出现了数据不一致问题

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-JMM.png)

### 12.3.2 内存间交互操作

JMM定义了以下8种操作完成变量从主存拷贝到工作内存、从工作内存到主存，这些操作都保证是原子性的，对于 double、long 类型的变量来说，load、store、read 和 write 在某些平台上有例外

- lock：锁定。作用于主内存的变量，它把一个变量标识为一条线程独占的状态
- unlock：解锁。作用域主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- read：读取。作用域主存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load：载入。作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use：使用。作用于工作内存的变量，它把工作内存中一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码执行就会执行这个操作
- assign：赋值。作用域工作内存变量，它把一个从执行以前引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
- store：存储。作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
- write：写入。作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主存的变量中

如果要把一个变量从主存拷贝到工作内存，那就要顺序执行 read 和 load

如果要把变量从工作内存同步回主内存，就要顺序执行 store 和 write

JMM要求上述两个操作是顺序的，但不要求紧挨着连续，也就是说这两个指令中间还可以插入其他指令

JMM要求以上命令满足以下规则：

- 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写但主内存不接受的情况
- 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须写回主存
- 不允许一个线程无原因的（没有发生任何assign操作）把数据从线程的工作内存同步回主内存
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作
- 一个变量在同一时刻只允许一条线程进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁
- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值
- 如果一个变量事先没有被lock操作锁定，那将不允许对它执行unlock操作，也不允许去lock一个被其他线程锁定的变量
- 对一个变量执行unlock操作之前，必须先把此变量同步回主存中（store、write）

### 12.3.3 对于volatile型变量的特殊规则

volatile只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性：

- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
- 变量不需要与其他的状态变量共同参与不变约束

当一个变量被定义为volatile之后，它将具备两种特性：

- 第一项是保证此变量对所有线程的可见性，指的是一个线程修改了此变量，新值对于其他线程来说是立即得知的。
  - 虽然volatile变量的值是每个线程立即可见的，但是还是不能保证对于volatile变量的所有写操作都是能立即反映到其线程中的。这是因为java中的运算操作并不是原子操作。当getstatic指令把变量值读取到操作栈顶时，volatile关键字保证了变量是正确的，但是到了iconst_1、iadd这些指令的时候，其他线程可能已经把该变量的值改变了，此时操作栈顶的值就是过期数据了，所以putstatic就会把较小的值同步回主存
- 第二个特性是禁止指令重排优化
  - 假设主线程先加载配置，加载好之后将标志位设置为true；子线程等待标志位，如果为true了就执行下面的代码（下面的代码依靠前面的配置加载）；如果指令重排，前面配置加载还没完成，标志位就先被设置了。这就导致了依靠配置的子线程出现并发错误



对于volatile变量，在赋值后字节码指令中会加入一个 `lock addl$0x0, (%esp)`，该句话的 `lock` 操作作用是将本处理器的缓存写入内存，该写入动作同时引起别的内核缓存无效化，这样就实现了volatile变量修改对其他处理器立即可见

处理器在指令重排时不是任意重排，也是要保证结果的正确性。因为 `lock` 操作需要将数据写入内存，因此在这一步之前已经获得了正确结果，对于后面的程序，这一块是没有指令重排过的。

### 12.3.4 针对long和double型变量的特殊规则



### 12.3.5 原子性、可见性和有序性

**1. 原子性（Atomicity）**

JMM直接保证原子性的变量操作包括 read、load、assign、use、store、write

还有lock和unlock

**2. 可见性（Visibility）**

volatile、synchronized、final保证可见性

**3. 有序性（Ordering）**



### 12.3.6 先行发生原则

先行发生原则（Happens-Before），是判断数据是否存在竞争，线程是否安全的非常重要的手段

线程A先行发生于线程B，那么线程B一定能观察到线程A的执行结果

示例1：

```java
//线程A
i=1

//线程B
j=i

//线程C
i=2		
```

在上面的示例中，假设线程A的操作先行发生于线程B的操作，那么我们可以确定线程B执行后，变量j的值一定是1。这是因为先行发生原则，B可以观察到A的结果，还有就是C还没登场，A修改后没有线程修改i的值。

如果A和B之间出现了操作C，但是C和B没有先行发生关系，那么j的值是不确定的，有可能是1，也有可能是2，这就发生了多线程不安全



天然先行发生原则：

- 程序次序原则：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于后面的操作
- 管程锁定规则：一个unlock操作先行发生于后面（时间上的后面）对同一个锁的lock操作
- volatile变量规则：对于一个volatile变量的写操作，先行发生于后面对这个变量的读操作
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
- 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测是否有中断发生
- 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始
- 传递性：A先于B，B先于C，那么肯定A先于C



示例2：

```java
private int value = 0;

public void setValue(int value){
	this.value = value;
}
public int getValue(){
	return value;
}
```

假设线程A先调用了setValue(1)方法，线程B后调用了同一个对象的getValue()，那么返回值是什么？

分析：由于两个方法由两个线程调用，不在一个线程中，不适用程序次序规则；由于没有同步块，没有lock和unlock操作，不适用管程锁定规则；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；其余规则和该程序没关系，因此不适用任何的先行发生原则，虽然线程A的操作先于线程B，但是无法确定返回结果，该操作就不是线程安全的

可以通过对getter/setter操作加锁进行锁定，套用管程锁定规则；或者value定义为volatile，由于setValue()不依赖原值，满足volatile关键字使用场景，这样可以套用volatile变量规则来实现先行发生关系。



## 12.4 Java与线程

### 12.4.1 线程的实现

**1. 内核线程实现**

**2. 用户线程实现**

**3. 混合实现**

**4. Java线程的实现**

每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己不会干涉线程调度，全权交给操作系统处理，何时唤醒冻结、该给线程分配多少执行时间、该把线程安排给哪个处理器核心去执行都是由操作系统完成的，也是由操作系统全权决定的。 



### 12.4.2 Java线程调度

线程调度的方式主要有两种：协同式和抢占式。

协同式线程调度的线程时间由线程本身来控制，线程把自己的工作执行完了之后，主动通知系统切换到另外一台线程上去。这样实现简单，不容易发生线程同步问题；也有可能由于编码问题，程序执行完没有切换到另一个线程，导致阻塞

抢占式线程调度的每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。可以通过设置优先级的方式，使得高优先级的进行越容易被执行（概率上）

### 12.4.3 状态转换

- 新建（new）：创建后未启动
- 运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是此线程可能正在执行，也可能正在等待操作系统分配执行时间
- 无限期等待（Waiting）：处于这种状态的线程不会被分配执行时间，需要等待其他线程的唤醒。
  - Object::wait()
  - Thread::join()：A线程中调用B.join()，代表B线程执行完才会执行A
  - LockSupport::park()：LockSupport.park() LockSupport.unpark(t1)
- 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配时间片，也不需要其他线程唤醒，到了设定时间系统就会自动唤醒
  - Thread::sleep()
  - 设置了Timeout参数的Object::wait()
  - 设置了Timeout参数的Thread::join()
  - LockSupport::parkNanos()
  - LockSupport::parkUntil()
- 阻塞（Blocked）：线程被阻塞了，阻塞状态与等待状态的区别是，阻塞状态在等待着获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；等待状态则是在等待一段时间或者唤醒动作的发生。在线程等待进入同步区域的时候，线程将进入这种状态。
- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行



## 12.5 Java与协程

### 12.5.1 内核线程的局限

### 12.5.2 协程的复苏

### 12.5.3 Java的解决方案





# 13 线程安全与锁优化

## 13.1 概述



## 13.2 线程安全

线程安全：当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

### 13.2.1 Java语言中的线程安全

我们将Java语言中的各种操作共享的数据分为五类：不可变】绝对线程安全、相对线程安全、县城兼容和线程对立

**1. 不可变**

不可变（Immutable）对象一定是线程安全的

String后者final

**2. 绝对线程安全**

**3. 相对线程安全**

**4. 线程兼容**

**5. 线程对立**

### 13.2.2 线程安全的实现方法

**1. 互斥同步**

互斥同步是一种最常见也是最主要的并发正确性保障手段，同步是指在多个线程并发访问数据时，保证共享数据在同一个时刻只被一条线程使用。而互斥同步是一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。

最基本的互斥同步手段是 synchronized 关键字，经过编译会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令。这两个字节码指令都需要一个 reference 类型的参数来指明要解锁的对象。如果 synchronized 明确制定了对象参数，那就以这个对象的引用作为 reference；如果没有明确指定，那就根据修饰的方法类型（实例方法和类方法）来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。

**在执行 monitorenter 指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了该对象的锁，就把锁的计数器的值加一，执行monitorexit 时计数器减一，一旦为零，锁立即被释放。如果获取对象锁失败，那当前线程就应当被阻塞等待，知道请求锁定的对象被持有它的线程释放为止。**

从上面可以得出：

- 被 synchronized 修饰的同步块对同一条线程来说是可重入的，这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况
- 被 synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。

从执行成本角度，持有锁是一个重量级操作。Java线程是映射到操作系统的原生内核线程之上，如果需要阻塞或者唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种转换需要耗费很多时间。

可重入锁（ReentrantLock）是Lock接口的一种实现，与 synchronized 都是可重入的，但增加了一些高级功能：

- 等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可终端特性对处理执行时间非常长的同步块很有帮助
- 公平锁：指当多个线程在等待同一个锁时，必须按照申请时间来依次获得锁；使用公平锁明显影响吞吐量
- 锁绑定多个条件：指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，在 synchronized 中，锁对象的 wait() 跟它的 notify() 或者 notifyAll() 方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不添加一个额外的锁；而 ReentrantLock 锁无需这样做，多次调用 newCondition() 方法即可。



**2. 非阻塞同步**

互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的开销（用户态和核心态的切换），因此这种同步称为阻塞同步。互斥同步属于一种悲观的并发策略，其总是认为只要不去做正确的同步措施，那就肯定会出现问题。

相对的，**还有一种基于冲突检测的乐观并发策略：不管风险，先进行操作，如果没有冲突就操作成功；如果共享的数据被争用，产生了冲突，那就再进行补偿措施，最常用的是不断重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此被称为非阻塞同步。**



乐观锁的实现涉及到操作和冲突检测，需要保证这两种操作的原子性，这需要从指令层面来保证（如果使用互斥同步方法就失去了非阻塞同步的意义），需要的命令：

- 测试并设置（Test-and-Set）
- 获取并增加(Fetch-and-Increment)
- 交换（swap）
- 比较并交换（Compare-and-Swap，CAS）
- 加载链接/条件储存（Load-Linked/Store-Conditional，LL/SC）

**3. 无同步方案**

同步与线程安全两者没有必然的联系，同步只是保障存在数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此有一些代码是天生安全的。

可重入代码（Reentrant Code）：这种代码又称为纯代码（Pure Code），是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有影响。所有可重入的代码都是线程安全的，但是不是所有线程安全的代码都是可重入的。

可重入代码的特征：不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入方法等。我们可以通过这个方法的结果是否是可预测的来判断这个代码是否是可重入的。

线程本地存储（Thread Local Storage）：如果一段代码所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一线程中执行。如果能保证，我们就可以把共享数据的可见范围在同一线程之内，这样无需同步也能保证线程之间不会出现数据争用的问题。

## 13.3 锁优化

JDK6 开始进行了锁优化，如适应性自选、锁消除、锁膨胀、轻量级锁、偏向锁

### 13.3.1 自旋锁与自适应自旋

前面提高互斥同步中阻塞线程和唤醒线程需要在用户态和内核态相互转换，这个操作十分费时。在很多时候往往后面的线程需要阻塞的时间比较短，如果物理机是多核心或者多路的，能够让两个线程并行的话，我们可以让后面的线程等待一会，但不放弃处理器的执行时间，避免状态切换开销。为了让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自旋锁等待不能代替阻塞，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，如果锁被占用的时间很短，自旋等待的效果就会非常好；如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源。因此自旋等待时间必须有一定的限度，如果自旋超过了限定的次数还没有获得锁，就应当使用传统的方式挂起线程。

后来对自旋锁进行优化，不再对自旋次数进行固定，而是根据前一次在同一个锁上的自选时间及锁的拥有者的状态来决定。如果同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待更长的时间；如果很少成功获得锁，那以后要获得这个锁就可能直接忽略掉自旋过程。

### 13.3.2 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以当作栈上的数据对待，认为是线程私有的。

### 13.3.3 锁粗化

一般的尽量将同步块的范围限制的尽量小，但是如果在一段代码中频繁的加锁和释放锁反而不如将同步块的范围放大。

### 13.3.4 轻量级锁

轻量级锁并不是代替重量级锁，设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

Hotspot虚拟机的对象头（Object Header）分为两部分，第一部分用于存储对象自身的运行时数据（哈希码，GC分代年龄等），这部分数据被称为 Mark Word。另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还有一个额外的部分存储数组长度。

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/JVM-MarkWord.png)

轻量级锁的工作过程：

- 在代码即将进入同步块的时候，如果此对象没有被锁定（锁标志位 01），虚拟机首先将在当前线程中的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。
- 然后虚拟机将使用CAS操作尝试把这个对象的Mark Word更新为指向Lock Record的指针。如果这个操作成功了，代表该线程拥有了这个对象的锁，并且Mark Word标志位变为 00 ，此时表示处于 轻量级锁状态。
- 如果更新操作失败，意味着至少存在一条线程与当前线程竞争获取该锁对象的锁，虚拟机首先会检查Mark Word是否指向当前线程的栈帧。如果是，代表当前线程已经获得了这个对象的锁，直接进入同步块执行，否则说明被其他线程抢占。如果出现两条以上的线程争用同一个锁，那轻量级锁就不再有效，必须要膨胀为重量级锁，所标志的状态值变为 10，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态

### 13.3.5 偏向锁

偏向锁的目的是消除数据在无竞争情况下的同步原语。轻量级锁在无竞争条件下还要使用CAS操作消除同步使用的互斥量，偏向锁在无竞争条件下把整个的同步过程都消除掉，连CAS都不需要

偏向锁会偏向于第一个获得他的线程

当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为01，把偏向模式设置为1，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在Mark Word中。如果CAS成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。

如果另一个线程尝试获得这个锁时，偏向模式宣告结束，根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为0），撤销后标志位恢复到未锁定或轻量级锁定，后续同步操作按照轻量级锁过程。

![](https://raw.githubusercontent.com/LiMuwenan/PicBed/master/img/dev/jvm/偏向锁轻量级锁转化.png)

如果计算过哈希码，对象头中就没有位置可以存储线程Id，这个对象也就不能再加偏向锁状态了；如果处于偏向锁的对象需要计算哈希时，也会立即撤销偏向状态，并且锁膨胀为重量级锁



